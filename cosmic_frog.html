<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COSMIC PARADISE // SYSTEM_HALTED</title>
    <!-- Three.js (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700&family=Share+Tech+Mono&family=Orbitron:wght@500;900&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050010;
            overflow: hidden;
            font-family: 'Share Tech Mono', 'Zen Maru Gothic', monospace; /* ハッカーっぽいフォント */
            color: white;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }

        /* --- Intro Layer --- */
        #white-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #ffffff;
            z-index: 300;
            transition: opacity 1.5s ease-out;
            pointer-events: none;
        }

        /* --- Main UI --- */
        #ui-layer {
            position: absolute;
            top: 30px; left: 30px;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 2s ease;
            display: none;
        }
        #ui-layer.visible { opacity: 1; }

        h1 {
            font-size: 2.5rem; margin: 0;
            color: #ff3333; /* エラー状態の赤 */
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            font-family: 'Orbitron', sans-serif;
            font-weight: 800;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 0.9rem; color: rgba(255, 100, 100, 0.8);
            margin-top: 5px; background: rgba(50,0,0,0.5);
            padding: 5px 15px; border-radius: 2px;
            border: 1px solid rgba(255,50,50,0.3);
            display: inline-block;
        }

        /* 詳細パネル（デバッグモニタ風） */
        #info-panel {
            position: absolute;
            top: 50%; right: 40px;
            transform: translateY(-50%) translateX(150%);
            width: 400px; /* 少し広く */
            background: rgba(10, 5, 5, 0.95);
            border: 1px solid rgba(255, 50, 50, 0.3);
            border-left: 4px solid #ff3333;
            backdrop-filter: blur(10px);
            padding: 30px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.9);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.4s ease;
            opacity: 0;
            pointer-events: auto;
            z-index: 20;
        }
        #info-panel.active { transform: translateY(-50%) translateX(0); opacity: 1; }

        .panel-header {
            display: flex; align-items: center; gap: 15px;
            margin-bottom: 20px; padding-bottom: 15px;
            border-bottom: 1px dashed rgba(255,50,50,0.3);
        }
        .panel-icon {
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; color: #ff3333;
            border: 1px solid #ff3333;
            background: rgba(255,0,0,0.1);
        }
        #panel-title { 
            margin: 0; color: #ff3333; font-size: 1.2rem; 
            font-family: 'Share Tech Mono', monospace; 
        }
        
        /* コード表示エリア */
        #panel-content {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #ccc;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border: 1px solid #333;
            margin-bottom: 10px;
            white-space: pre-wrap; /* 改行維持 */
        }
        
        .code-fragment {
            color: #00ffaa;
            font-weight: bold;
        }

        .close-btn {
            position: absolute; top: 15px; right: 15px;
            background: transparent; border: none;
            color: #666; cursor: pointer; transition: 0.2s;
            font-size: 1.2rem;
        }
        .close-btn:hover { color: #fff; }

        .status-bar {
            font-size: 0.7rem;
            color: #666;
            border-top: 1px solid #333;
            padding-top: 10px;
            display: flex;
            justify-content: space-between;
        }

        /* 覚醒後のアクションボタン */
        #action-btn-container {
            display: none; /* デフォルト非表示 */
            margin-top: 15px;
        }
        .action-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(90deg, #00ffaa, #00aaff);
            border: none;
            border-radius: 4px;
            color: #000;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.6);
        }
        .action-btn:active { transform: translateY(0); }

        /* カーソルラベル */
        #cursor-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #ff3333;
            padding: 5px 10px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            pointer-events: none; opacity: 0;
            transform: scale(0.9); transition: 0.1s;
            border: 1px solid #ff3333;
            z-index: 30;
        }
        #cursor-label.visible { opacity: 1; transform: scale(1); }

        .nav-hint {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 20px;
            pointer-events: none; opacity: 0;
            transition: opacity 2s ease;
            font-family: 'Share Tech Mono', monospace;
            color: #666;
            font-size: 0.8rem;
        }
        .nav-hint.visible { opacity: 1; }

        /* AWAKENED STATE (System Repaired) */
        body.awakened h1 { 
            color: #00ffaa; 
            text-shadow: 0 0 20px #00ffaa; 
        }
        body.awakened .subtitle { 
            color: #00ffaa; border-color: #00ffaa; background: rgba(0,50,20,0.5); 
        }
        body.awakened #info-panel {
            border-left-color: #00ffaa;
            border-color: rgba(0,255,170,0.3);
            background: rgba(0, 10, 20, 0.9);
        }
        body.awakened .panel-icon { color: #00ffaa; border-color: #00ffaa; background: rgba(0,255,170,0.1); }
        body.awakened #panel-title { color: #00ffaa; }
        body.awakened #cursor-label { color: #00ffaa; border-color: #00ffaa; }
        body.awakened .panel-header { border-bottom-color: rgba(0,255,170,0.3); }
        body.awakened #panel-content { color: #aaffdd; border-color: rgba(0,255,170,0.2); background: rgba(0,20,10,0.3); }

    </style>
</head>
<body>

    <div id="white-layer"></div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <h1 id="main-title">SYSTEM_HALTED</h1>
        <div class="subtitle" id="main-subtitle"><i class="fas fa-exclamation-triangle"></i> CRITICAL DRIVER MISSING</div>
    </div>

    <div id="cursor-label">FRAGMENT_DETECTED</div>

    <div id="info-panel">
        <button class="close-btn" onclick="resetView(event)"><i class="fas fa-times"></i></button>
        <div class="panel-header">
            <div class="panel-icon"><i class="fas fa-bug"></i></div>
            <h2 id="panel-title">DEBUG_LOG</h2>
        </div>
        <div id="panel-content">
            <!-- Code snippet goes here -->
        </div>
        
        <!-- 覚醒後に出現するボタン -->
        <div id="action-btn-container">
            <button class="action-btn" id="action-btn">EXECUTE</button>
        </div>

        <div class="status-bar">
            <span id="status-code">ERR_CODE: 0xDEADBEEF</span>
            <span id="status-level">LEVEL: KERNEL</span>
        </div>
    </div>

    <div class="nav-hint" id="nav-hint">
        [CLICK] INSPECT MEMORY // [DRAG] PAN CAMERA // [F12] TERMINAL
    </div>

    <script>
        // --- Configuration ---
        const config = {
            bgColor: 0x050010,
            planetSize: 4.5,
            frogColor: 0x555555, // 停止中はグレー
            warpColor: 0x00ffff,
            starColor: 0xffffff
        };

        const state = {
            phase: 'white_out',
            warpSpeed: 0,
            targetWarpSpeed: 0,
            isAwakened: false // 謎解き完了フラグ
        };

        // --- Puzzle Data & Awakened Functions ---
        const facilities = [
            { 
                id: 'server', name: 'CORE_SERVER', icon: 'fa-server', color: 0xff3333, phi: 2.0, theta: 0.8, type: 'monolith',
                log: `[CRITICAL ERROR]\nDriver 'CosmicDriver' is undefined.\nSystem cannot initialize planetary rotation.`,
                // Awakened
                awakenedTitle: 'SYSTEM_CORE',
                awakenedLog: 'System is stable.\nCore performance: 100%\nUptime: Just started.',
                actionLabel: 'REBOOT WORLD',
                actionType: 'reload'
            },
            { 
                id: 'library', name: 'LIB_ARCHIVE', icon: 'fa-book', color: 0xff3333, phi: 1.2, theta: 0, type: 'library',
                log: `[MANUAL_PAGE_01]\nTo repair the system, you must define a class named <span class="code-fragment">CosmicDriver</span> in the global scope.`,
                // Awakened
                awakenedTitle: 'GATEWAY_LINK',
                awakenedLog: 'External knowledge base connection established.\nReady to jump.',
                actionLabel: 'VISIT THREE.JS DOCS',
                actionType: 'link',
                url: 'https://threejs.org/'
            },
            { 
                id: 'observatory', name: 'OBS_TELESCOPE', icon: 'fa-eye', color: 0xff3333, phi: 1.0, theta: 3.5, type: 'observatory',
                log: `[MANUAL_PAGE_02]\nThe <span class="code-fragment">CosmicDriver</span> constructor must accept one argument:\n<span class="code-fragment">starCount</span> (Integer).`,
                // Awakened
                awakenedTitle: 'WARP_CONTROL',
                awakenedLog: 'Starfield propulsion engine.\nCurrent status: Idle',
                actionLabel: 'TOGGLE HYPERDRIVE',
                actionType: 'warp_speed'
            },
            { 
                id: 'garden', name: 'MEM_GARDEN', icon: 'fa-tree', color: 0xff3333, phi: 1.8, theta: 1.5, type: 'garden',
                log: `[MEMORY_DUMP]\nScanning local sector...\nCurrent star count detected: <span class="code-fragment">88</span>`,
                // Awakened
                awakenedTitle: 'FLORA_GENERATOR',
                awakenedLog: 'Digital cultivation module active.\nSeed bank: Unlimited.',
                actionLabel: 'PLANT FLOWERS',
                actionType: 'spawn_flowers'
            },
            { 
                id: 'shrine', name: 'GATE_KEEPER', icon: 'fa-torii-gate', color: 0xff3333, phi: 1.5, theta: 4.5, type: 'torii',
                log: `[MANUAL_PAGE_03]\nThe class must implement a method named <span class="code-fragment">ignite(fuel)</span>.\nThis method triggers the core fusion.`,
                // Awakened
                awakenedTitle: 'COSMIC_ORACLE',
                awakenedLog: 'Connection to divine matrix active.\nQuerying future...',
                actionLabel: 'DRAW FORTUNE',
                actionType: 'omikuji'
            },
            { 
                id: 'cafe', name: 'CACHE_BUFFER', icon: 'fa-coffee', color: 0xff3333, phi: 1.4, theta: 5.8, type: 'cafe',
                log: `[MANUAL_PAGE_04]\nInside 'ignite(fuel)':\nIf the argument <span class="code-fragment">fuel</span> equals the string <span class="code-fragment">'LOVE'</span>,\nreturn <span class="code-fragment">true</span>.\nOtherwise, return false.`,
                // Awakened
                awakenedTitle: 'LOUNGE_AREA',
                awakenedLog: 'Refreshment module.\nFrog happiness level: 100%',
                actionLabel: 'CHEER UP FROG',
                actionType: 'frog_dance'
            },
            { 
                id: 'market', name: 'DATA_EXCHANGE', icon: 'fa-exchange-alt', color: 0xff3333, phi: 2.2, theta: 2.5, type: 'market',
                log: `[NETWORK_LOG]\nConnection Refused.\nAuthentication Protocol: Custom Class Injection required.`,
                // Awakened
                awakenedTitle: 'SKIN_SHOP',
                awakenedLog: 'Customization protocol available.\nModify entity parameters.',
                actionLabel: 'CHANGE FROG COLOR',
                actionType: 'change_color'
            },
            { 
                id: 'fountain', name: 'ROOT_ACCESS', icon: 'fa-terminal', color: 0xff3333, phi: 2.5, theta: 5.0, type: 'fountain',
                log: `[ADMIN_CONSOLE]\nTo restart the system, instantiate your driver and mount it:\n\n<span class="code-fragment">window.PARADISE_SYSTEM.mount(new CosmicDriver(88));</span>`,
                // Awakened
                awakenedTitle: 'CELEBRATION_UNIT',
                awakenedLog: 'Victory state confirmed.\nDeploying visual rewards.',
                actionLabel: 'LAUNCH FIREWORKS',
                actionType: 'fireworks'
            }
        ];

        // --- Globals ---
        let scene, camera, renderer, controls;
        let planetGroup, frogGroup, poiGroup, particleGroup;
        let warpStars, farStars;
        let raycaster, mouse;
        let hoveredObj = null;
        let targetCameraPos = null;
        let targetControlsTarget = null;
        let isFocusing = false;
        let clock = new THREE.Clock();
        
        // For Effects
        let tempParticles = [];

        // --- SYSTEM CORE (The Puzzle Validator) ---
        window.PARADISE_SYSTEM = {
            mounted: false,
            mount: function(driverInstance) {
                console.log("%c[SYSTEM] Mounting driver...", "color:yellow");

                if (!driverInstance) {
                    console.error("[SYSTEM] Error: No instance provided.");
                    return;
                }
                
                if (driverInstance.constructor.name !== 'CosmicDriver') {
                    console.error("[SYSTEM] Error: Invalid Driver Class. Expected 'CosmicDriver'.");
                    return;
                }

                if (driverInstance.starCount !== 88) {
                    console.error(`[SYSTEM] Error: Star count mismatch. Expected 88, got ${driverInstance.starCount}.`);
                    return;
                }

                if (typeof driverInstance.ignite !== 'function') {
                    console.error("[SYSTEM] Error: Method 'ignite' not implemented.");
                    return;
                }

                if (driverInstance.ignite('HATE') === true || driverInstance.ignite('LOVE') !== true) {
                    console.error("[SYSTEM] Error: 'ignite' method logic verification failed.");
                    return;
                }

                this.awaken();
            },
            awaken: function() {
                if(this.mounted) return;
                this.mounted = true;
                state.isAwakened = true;
                
                console.clear();
                console.log("%c[SYSTEM] DRIVER ACCEPTED. REBOOTING UNIVERSE...", "color: #00ffaa; font-size: 20px; font-weight: bold;");
                
                // Visual Updates
                document.body.classList.add('awakened');
                document.getElementById('main-title').innerText = "NIRVANA-09";
                document.getElementById('main-title').style.color = "#00ffaa";
                document.getElementById('main-subtitle').innerHTML = '<i class="fas fa-check-circle"></i> SYSTEM ONLINE';
                
                resetView();
                triggerAwakeningEffect();
            }
        };

        // --- Init ---
        function init() {
            console.log("%c[SYSTEM] BOOT FAILURE. MANUAL OVERRIDE REQUIRED.", "color: red; font-size: 16px; font-weight: bold;");
            console.log("Check the facilities in the 3D view to reconstruct the `CosmicDriver` class.");

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(config.bgColor, 50, 8000); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000); 
            camera.position.z = 20000; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.minDistance = 8;
            controls.maxDistance = 40;
            controls.enablePan = false;
            controls.enabled = false;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            setupLights();
            createStarField(); 
            createPlanet();
            createCuteFrog();
            createFacilities();
            
            // Particle system for effects
            particleGroup = new THREE.Group();
            scene.add(particleGroup);
            
            planetGroup.visible = true; 

            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onClick);

            startSequence();
            animate();
        }

        // --- Transition Sequence ---
        function startSequence() {
            setTimeout(() => {
                const whiteLayer = document.getElementById('white-layer');
                whiteLayer.style.opacity = 0;
                
                state.phase = 'warping';
                state.warpSpeed = 200;
                state.targetWarpSpeed = 200;

                setTimeout(() => whiteLayer.style.display = 'none', 1500);

                setTimeout(() => {
                    startApproach();
                }, 2000); 

            }, 1000); 
        }

        function startApproach() {
            state.phase = 'arriving';
            state.targetWarpSpeed = 0.5; 
            
            const startZ = 10000;
            const endZ = 16;
            const startFOV = 150;
            const endFOV = 50;
            const startFogNear = 50;
            const endFogNear = 100;
            const startFogFar = 8000;
            const endFogFar = 15000;

            let progress = 0;
            
            const approachLoop = () => {
                progress += 0.008; 
                const t = Math.min(progress, 1);
                const ease = 1 - Math.pow(1 - t, 4);

                camera.position.z = startZ + (endZ - startZ) * ease;
                camera.fov = startFOV + (endFOV - startFOV) * ease;
                camera.updateProjectionMatrix();

                scene.fog.near = startFogNear + (endFogNear - startFogNear) * ease;
                scene.fog.far = startFogFar + (endFogFar - startFogFar) * ease;

                planetGroup.rotation.y = (1 - ease) * Math.PI; 

                if (t < 1) {
                    requestAnimationFrame(approachLoop);
                } else {
                    state.phase = 'arrived';
                    controls.enabled = true;
                    state.warpSpeed = 0.2; 
                    
                    document.getElementById('ui-layer').classList.add('visible');
                    document.getElementById('ui-layer').style.display = 'block';
                    document.getElementById('nav-hint').classList.add('visible');
                }
            };
            approachLoop();
        }

        // --- 3D Objects Construction ---
        
        function setupLights() {
            const ambient = new THREE.AmbientLight(0x404060, 1.2);
            scene.add(ambient);
            const sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(20, 30, 20);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            scene.add(sun);
            const rim = new THREE.SpotLight(0x00ffff, 2, 50);
            rim.position.set(-20, 10, -10);
            rim.lookAt(0, 0, 0);
            scene.add(rim);
        }

        function createStarField() {
            const farGeo = new THREE.BufferGeometry();
            const farCount = 5000;
            const farPos = new Float32Array(farCount * 3);
            for(let i=0; i<farCount*3; i++) farPos[i] = (Math.random() - 0.5) * 30000;
            farGeo.setAttribute('position', new THREE.BufferAttribute(farPos, 3));
            const farMat = new THREE.PointsMaterial({color: 0x8888aa, size: 2, transparent: true, opacity: 0.8, sizeAttenuation: false});
            farStars = new THREE.Points(farGeo, farMat);
            scene.add(farStars);

            const warpGeo = new THREE.BufferGeometry();
            const warpCount = 4000;
            const warpPos = new Float32Array(warpCount * 3);
            const warpCol = new Float32Array(warpCount * 3);
            const c1 = new THREE.Color(0x00ffff);
            const c2 = new THREE.Color(0xff00ff);
            
            for(let i=0; i<warpCount; i++) {
                const r = 500 + Math.random() * 4000;
                const theta = Math.random() * Math.PI * 2;
                const z = (Math.random() - 0.5) * 40000;
                warpPos[i*3] = r * Math.cos(theta);
                warpPos[i*3+1] = r * Math.sin(theta);
                warpPos[i*3+2] = z;
                const c = Math.random() > 0.5 ? c1 : c2;
                warpCol[i*3] = c.r; warpCol[i*3+1] = c.g; warpCol[i*3+2] = c.b;
            }
            warpGeo.setAttribute('position', new THREE.BufferAttribute(warpPos, 3));
            warpGeo.setAttribute('color', new THREE.BufferAttribute(warpCol, 3));
            const warpMat = new THREE.PointsMaterial({
                size: 3, vertexColors: true, transparent: true, opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            warpStars = new THREE.Points(warpGeo, warpMat);
            scene.add(warpStars);
        }

        function createPlanet() {
            planetGroup = new THREE.Group();
            
            const ocean = new THREE.Mesh(new THREE.IcosahedronGeometry(config.planetSize, 4), new THREE.MeshPhysicalMaterial({ color: 0x1144aa, roughness: 0.2, metalness: 0.1, transmission: 0.4, opacity: 0.9, transparent: true }));
            planetGroup.add(ocean);
            planetGroup.add(new THREE.Mesh(new THREE.IcosahedronGeometry(config.planetSize * 0.5, 2), new THREE.MeshBasicMaterial({ color: 0x00ffff })));
            planetGroup.add(new THREE.Mesh(new THREE.IcosahedronGeometry(config.planetSize * 1.25, 3), new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.15, side: THREE.BackSide, blending: THREE.AdditiveBlending })));

            // 岩の生成 (30個)
            const landMat = new THREE.MeshStandardMaterial({ color: 0x44cc88, flatShading: true, roughness: 0.8 });
            const maxRocks = 30; 
            const maxAttempts = 500; 
            const frogSafeDist = 1.0; 
            const facilitySafeDist = 0.5;
            const rockSafeDist = 0.3;

            let rockCount = 0;
            const existingPositions = []; 

            facilities.forEach(fac => {
                existingPositions.push({ vec: new THREE.Vector3().setFromSphericalCoords(1, fac.phi, fac.theta), type: 'facility' });
            });

            for(let i=0; i<maxAttempts && rockCount < maxRocks; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1); 

                if (phi < frogSafeDist) continue; 
                if (phi > Math.PI - 0.3) continue;

                const p1 = new THREE.Vector3().setFromSphericalCoords(1, phi, theta);
                let collision = false;

                for(let item of existingPositions) {
                    const dist = p1.distanceTo(item.vec);
                    const threshold = (item.type === 'facility') ? facilitySafeDist : rockSafeDist;
                    if (dist < threshold) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    const r = config.planetSize;
                    const size = Math.random() * 0.5 + 0.4;
                    const land = new THREE.Mesh(new THREE.DodecahedronGeometry(size, 0), landMat);
                    land.position.setFromSphericalCoords(r, phi, theta);
                    land.lookAt(0,0,0);
                    land.castShadow = true; land.receiveShadow = true;
                    land.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                    planetGroup.add(land);
                    existingPositions.push({ vec: p1, type: 'rock' });
                    rockCount++;
                }
            }
            scene.add(planetGroup);
        }

        function createCuteFrog() {
            frogGroup = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: config.frogColor, roughness: 0.6, metalness: 0.1 });
            const bellyMat = new THREE.MeshStandardMaterial({ color: 0x888888 }); // 最初は暗く
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.3, 32, 24), mat);
            head.scale.set(1.1, 0.8, 1); head.position.y = 0.5; head.castShadow = true;
            frogGroup.add(head);

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 24), mat);
            body.position.y = -0.5; body.scale.y = 0.9; body.castShadow = true;
            frogGroup.add(body);
            
            const belly = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 24), bellyMat);
            belly.position.set(0, -0.5, 0.55); belly.scale.set(1.1, 0.9, 0.4);
            belly.name = "belly";
            frogGroup.add(belly);

            // Eyes (Closed initially)
            const eyeW = new THREE.MeshBasicMaterial({color:0x333333}); // 暗い目
            function makeEye(x) {
                const g = new THREE.Group();
                const base = new THREE.Mesh(new THREE.SphereGeometry(0.5, 24, 24), mat);
                const white = new THREE.Mesh(new THREE.SphereGeometry(0.35, 24, 24), eyeW); 
                white.position.set(0, 0.15, 0.25); white.name = "eyeWhite";
                g.add(base, white); g.position.set(x, 1.2, 0.3); g.rotation.x = -0.3; g.rotation.y = x * 0.2; return g;
            }
            frogGroup.add(makeEye(0.7), makeEye(-0.7));

            // Crown
            const crown = new THREE.Group();
            const cBase = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.3, 0.4, 8), new THREE.MeshStandardMaterial({color:0x554400, metalness:0.6, roughness:0.5}));
            cBase.name = "crownBase";
            crown.add(cBase);
            crown.position.set(0.5, 1.8, 0); crown.rotation.z = -0.4; crown.userData = {isCrown:true};
            frogGroup.add(crown);

            // Limbs
            const limbGeo = new THREE.SphereGeometry(0.25, 16, 16); limbGeo.scale(1, 1.5, 1);
            const armL = new THREE.Mesh(limbGeo, mat); armL.position.set(0.8, -0.3, 0.5); armL.rotation.set(-0.5, 0, -0.5);
            const armR = new THREE.Mesh(limbGeo, mat); armR.position.set(-0.8, -0.3, 0.5); armR.rotation.set(-0.5, 0, 0.5);
            const legL = new THREE.Mesh(limbGeo, mat); legL.position.set(0.6, -0.9, 0.4); legL.rotation.x = -1.5;
            const legR = new THREE.Mesh(limbGeo, mat); legR.position.set(-0.6, -0.9, 0.4); legR.rotation.x = -1.5;
            frogGroup.add(armL, armR, legL, legR);

            frogGroup.position.set(0, config.planetSize + 0.8, 0);
            planetGroup.add(frogGroup);
        }

        // --- FACILITIES ---
        function createFacilities() {
            poiGroup = new THREE.Group();
            facilities.forEach(data => {
                const group = new THREE.Group();
                const r = config.planetSize;
                const x = r * Math.sin(data.phi) * Math.sin(data.theta);
                const y = r * Math.cos(data.phi);
                const z = r * Math.sin(data.phi) * Math.cos(data.theta);
                group.position.set(x, y, z);
                group.lookAt(0, 0, 0);

                const mat = new THREE.MeshStandardMaterial({ color: 0x550000, emissive: 0x550000, emissiveIntensity: 0.8, roughness: 0.2 }); // エラー色
                const mainMesh = new THREE.Group();

                // 簡易形状（詳細形状は前回同様だが、色はエラー状態）
                let geo;
                if (data.type === 'monolith') geo = new THREE.BoxGeometry(0.6, 1.5, 0.6);
                else geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                
                // タイプ別の形状（簡略化して実装）
                if(data.type==='torii'){
                    const m = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,0.2), mat); mainMesh.add(m); mainMesh.position.z = -0.5;
                } else if(data.type==='library'){
                    const m = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.2,0.8), mat); mainMesh.add(m); mainMesh.rotation.x=Math.PI/2;
                } else {
                    const m = new THREE.Mesh(geo, mat); mainMesh.add(m); mainMesh.rotation.x = -Math.PI/2;
                }

                group.add(mainMesh);

                // Beam (Red Error Beam)
                const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.15, 6, 8), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending }));
                beam.rotation.x = -Math.PI/2; beam.position.z = -3; group.add(beam);

                const hitBox = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({ visible: false }));
                hitBox.userData = { isPOI: true, info: data }; group.add(hitBox);
                
                group.userData = { isPOIGroup: true, info: data, mesh: mainMesh, beam: beam };
                poiGroup.add(group);
            });
            planetGroup.add(poiGroup);
        }

        // --- WIN EFFECT ---
        function triggerAwakeningEffect() {
            // 1. Change Frog Colors
            frogGroup.children.forEach(child => {
                if(child.material) child.material.color.setHex(0x99ff99); // Green
                if(child.name === "belly") child.material.color.setHex(0xffffdd);
                if(child.name === "eyeWhite") child.material.color.setHex(0xffffff);
            });
            
            // 2. Change Facilities Colors
            poiGroup.children.forEach(g => {
                const info = g.userData.info;
                // Beam to Green
                g.userData.beam.material.color.setHex(0x00ffaa);
                g.userData.beam.scale.set(1, 2, 1);
                // Mesh to Blue/Green
                g.userData.mesh.children.forEach(m => {
                    m.material.color.setHex(0x00aaff);
                    m.material.emissive.setHex(0x00ffaa);
                });
            });

            // 3. Atmosphere Brighten
            planetGroup.children[2].material.opacity = 0.4;
            planetGroup.children[2].material.color.setHex(0x00ffaa);

            // 4. Background Stars Shift
            warpStars.material.vertexColors = false;
            warpStars.material.color.setHex(0xaaffaa);
        }

        // --- AWAKENED ACTIONS ---
        function executeFacilityAction(facility) {
            if (!state.isAwakened) return;

            console.log("Action Triggered:", facility.actionType);

            switch(facility.actionType) {
                case 'link':
                    if(confirm("外部データベースに接続しますか？\n" + facility.url)) {
                        window.open(facility.url, '_blank');
                    }
                    break;
                case 'reload':
                    if(confirm("システムを再起動しますか？")) {
                        location.reload();
                    }
                    break;
                case 'spawn_flowers':
                    spawnEffect('flowers');
                    alert("庭園にデータフラワーが咲きました！");
                    break;
                case 'fireworks':
                    spawnEffect('fireworks');
                    break;
                case 'change_color':
                    const r = Math.random();
                    const g = Math.random();
                    const b = Math.random();
                    frogGroup.children.forEach(child => {
                        if(child.material && child.name !== 'belly' && child.name !== 'eyeWhite') {
                            child.material.color.setRGB(r, g, b);
                        }
                    });
                    break;
                case 'warp_speed':
                    state.targetWarpSpeed = (state.targetWarpSpeed > 10) ? 0.2 : 50;
                    break;
                case 'frog_dance':
                    // Simple jump
                    let jumpY = 0;
                    const jumpInterval = setInterval(() => {
                        jumpY += 0.2;
                        frogGroup.position.y += Math.sin(jumpY);
                        if(jumpY > Math.PI*2) {
                            clearInterval(jumpInterval);
                        }
                    }, 16);
                    break;
                case 'omikuji':
                    const fortunes = ["大吉 (Excellent)", "中吉 (Good)", "小吉 (Okay)", "凶 (Bug Found)"];
                    const res = fortunes[Math.floor(Math.random() * fortunes.length)];
                    alert("COSMIC FORTUNE: " + res);
                    break;
            }
        }

        function spawnEffect(type) {
            // Simple Particle Effect
            const count = 50;
            const geo = new THREE.BufferGeometry();
            const pos = [];
            const col = [];
            const vel = [];
            
            for(let i=0; i<count; i++) {
                // Random position above planet
                const r = config.planetSize + 2 + Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                pos.push(x, y, z);
                
                if (type === 'flowers') {
                    col.push(Math.random(), Math.random(), Math.random());
                    vel.push(0, 0, 0); // Static
                } else {
                    // Fireworks explode out
                    col.push(1, 0.5 + Math.random()*0.5, 0);
                    vel.push(x*0.02, y*0.02, z*0.02);
                }
            }
            
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
            
            const mat = new THREE.PointsMaterial({size: (type==='flowers'?0.3:0.5), vertexColors:true});
            const mesh = new THREE.Points(geo, mat);
            
            if(type === 'fireworks') {
                mesh.userData = { vel: vel, age: 0 };
                tempParticles.push(mesh);
                scene.add(mesh);
            } else {
                // Flowers stay
                particleGroup.add(mesh);
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (warpStars) {
                const pos = warpStars.geometry.attributes.position.array;
                state.warpSpeed += (state.targetWarpSpeed - state.warpSpeed) * 0.05;
                for(let i=2; i<pos.length; i+=3) {
                    pos[i] += state.warpSpeed;
                    if(pos[i] > 15000) pos[i] -= 30000;
                }
                warpStars.geometry.attributes.position.needsUpdate = true;
                warpStars.rotation.z += 0.002 * (state.warpSpeed / 100);
            }

            // Temp Particles (Fireworks)
            for(let i=tempParticles.length-1; i>=0; i--) {
                const p = tempParticles[i];
                const pos = p.geometry.attributes.position.array;
                const vel = p.userData.vel;
                p.userData.age++;
                
                for(let j=0; j<pos.length/3; j++) {
                    pos[j*3] += vel[j*3];
                    pos[j*3+1] += vel[j*3+1];
                    pos[j*3+2] += vel[j*3+2];
                }
                p.geometry.attributes.position.needsUpdate = true;
                p.material.opacity = 1 - (p.userData.age / 60);
                
                if(p.userData.age > 60) {
                    scene.remove(p);
                    tempParticles.splice(i, 1);
                }
            }

            if (state.phase === 'arrived') {
                if (!isFocusing && !document.getElementById('info-panel').classList.contains('active')) {
                    raycaster.setFromCamera(mouse, camera);
                    let targets = [];
                    poiGroup.children.forEach(g => { g.children.forEach(c => { if (c.userData.isPOI) targets.push(c); }); });
                    const intersects = raycaster.intersectObjects(targets);
                    const label = document.getElementById('cursor-label');

                    if (intersects.length > 0) {
                        const hit = intersects[0].object;
                        if (hoveredObj !== hit) {
                            hoveredObj = hit;
                            document.body.style.cursor = 'pointer';
                            hit.parent.scale.setScalar(1.2);
                            label.textContent = state.isAwakened ? hit.userData.info.awakenedTitle : "FRAGMENT: " + hit.userData.info.name;
                            label.classList.add('visible');
                        }
                    } else {
                        if (hoveredObj) {
                            hoveredObj.parent.scale.setScalar(1);
                            hoveredObj = null;
                            document.body.style.cursor = 'default';
                            label.classList.remove('visible');
                        }
                    }
                }

                if (targetCameraPos) {
                    camera.position.lerp(targetCameraPos, 0.05);
                    if (camera.position.distanceTo(targetCameraPos) < 0.5 && !isFocusing && camera.position.z > 15) {
                        controls.autoRotate = true; targetCameraPos = null;
                    }
                }
                if (targetControlsTarget) controls.target.lerp(targetControlsTarget, 0.05);

                if(frogGroup) {
                    // 覚醒前は動かない、覚醒後は動く
                    const intensity = state.isAwakened ? 1 : 0.1;
                    frogGroup.position.y = (config.planetSize + 0.8) + Math.sin(time * 2) * 0.1 * intensity;
                    
                    if(state.isAwakened) {
                        frogGroup.children.forEach(c => {
                            if(c.userData.isCrown) {
                                c.position.y = 1.8 + Math.sin(time*3)*0.05;
                                c.rotation.z = -0.4 + Math.sin(time)*0.1;
                            }
                        });
                    }
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function onMouseMove(e) {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            const label = document.getElementById('cursor-label');
            label.style.left = (e.clientX + 20) + 'px';
            label.style.top = (e.clientY + 20) + 'px';
        }
        function onClick(e) {
            if(document.getElementById('info-panel').classList.contains('active')) return;
            if(hoveredObj) focusOnFacility(hoveredObj.userData.info, hoveredObj.parent);
        }

        function focusOnFacility(data, group) {
            isFocusing = true;
            controls.autoRotate = false;
            
            const panel = document.getElementById('info-panel');
            const titleEl = document.getElementById('panel-title');
            const contentEl = document.getElementById('panel-content');
            const iconBox = document.querySelector('.panel-icon');
            const actionBtnCont = document.getElementById('action-btn-container');
            const actionBtn = document.getElementById('action-btn');
            
            if (state.isAwakened) {
                // 覚醒後：機能パネル表示
                titleEl.innerText = data.awakenedTitle;
                contentEl.innerHTML = data.awakenedLog;
                titleEl.style.color = "#00ffaa";
                iconBox.style.color = "#00ffaa";
                iconBox.style.borderColor = "#00ffaa";
                
                // アクションボタン設定
                actionBtnCont.style.display = 'block';
                actionBtn.innerText = data.actionLabel;
                
                // ボタンクリックイベントを上書き
                actionBtn.onclick = () => {
                    executeFacilityAction(data);
                };

            } else {
                // 覚醒前：ログ表示
                titleEl.innerText = data.name + " // LOG";
                contentEl.innerHTML = data.log;
                titleEl.style.color = "#ff3333";
                iconBox.style.color = "#ff3333";
                iconBox.style.borderColor = "#ff3333";
                actionBtnCont.style.display = 'none';
            }
            
            panel.classList.add('active');

            const worldPos = new THREE.Vector3();
            group.getWorldPosition(worldPos);
            targetControlsTarget = worldPos.clone();
            const dir = worldPos.clone().normalize();
            targetCameraPos = dir.multiplyScalar(config.planetSize + 6);
        }

        window.resetView = function(e) {
            if(e) e.stopPropagation();
            isFocusing = false;
            document.getElementById('info-panel').classList.remove('active');
            targetCameraPos = new THREE.Vector3(0, 5, 16);
            targetControlsTarget = new THREE.Vector3(0, 0, 0);
        }

        init();

    </script>
</body>
</html>
