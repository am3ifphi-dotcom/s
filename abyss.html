<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCHIVE_CORE // AM3I</title>
    <!-- Three.js (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&family=Share+Tech+Mono&family=Noto+Sans+JP:wght@300;400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050005; /* Dark Purple tint */
            overflow: hidden;
            font-family: 'Share Tech Mono', monospace;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: filter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        
        body.modal-open #canvas-container {
            filter: brightness(0.6) blur(2px); 
        }

        /* --- Intro UI --- */
        #intro-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 20;
            transition: opacity 0.5s;
        }

        .hold-btn {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 2px solid rgba(180, 0, 255, 0.3); /* Purple for Serpent */
            background: rgba(10, 0, 20, 0.8);
            color: #d000ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            position: relative;
            box-shadow: 0 0 30px rgba(100, 0, 200, 0.2);
            transition: transform 0.1s, border-color 0.3s, color 0.3s, box-shadow 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0 auto;
            backdrop-filter: blur(5px);
        }
        
        .hold-btn:active {
            transform: scale(0.95);
        }

        .hold-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(200, 0, 255, 0.8);
            animation: pulseText 2s infinite;
        }

        .progress-ring {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 150px;
            height: 150px;
            transform: rotate(-90deg);
            pointer-events: none;
        }
        .progress-ring__circle {
            stroke: #aa00ff;
            stroke-width: 6;
            fill: transparent;
            stroke-dasharray: 440;
            stroke-dashoffset: 440;
            transition: stroke-dashoffset 0.05s linear;
            filter: drop-shadow(0 0 5px #aa00ff);
        }

        @keyframes pulseText {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* --- Main UI --- */
        #main-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.5s ease-in;
            display: none;
        }

        .header-info {
            position: absolute;
            top: 30px;
            left: 30px;
            color: rgba(200, 100, 255, 0.8);
            transition: color 0.5s;
        }
        .header-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 15px #aa00ff;
            letter-spacing: 4px;
            transition: text-shadow 0.5s, color 0.5s;
        }
        .alert-sub {
            color: #ff0055;
            font-weight: bold;
            animation: blink 1s infinite;
        }
        
        @keyframes blink { 50% { opacity: 0.5; } }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            background: rgba(0,0,0,0.8);
            padding: 8px 15px;
            border-left: 2px solid #aa00ff;
            transition: border-color 0.5s;
            font-family: 'Share Tech Mono', monospace;
        }
        .controls-hint strong {
            color: #aa00ff;
            text-decoration: underline;
        }

        #return-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(20, 0, 20, 0.6);
            border: 1px solid #aa00ff;
            color: #aa00ff;
            padding: 10px 30px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        #return-btn:hover {
            background: #aa00ff;
            color: #fff;
            box-shadow: 0 0 20px #aa00ff;
        }

        /* --- Flash Overlay --- */
        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-out;
        }

        /* --- Archive Modal --- */
        #archive-modal {
            position: fixed;
            top: 0;
            right: 0;
            width: 500px;
            max-width: 90%;
            height: 100%;
            background: rgba(10, 0, 15, 0.95);
            border-left: 1px solid rgba(170, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 200;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            box-shadow: -20px 0 50px rgba(0, 0, 0, 0.8);
        }

        #archive-modal.active {
            transform: translateX(0);
        }

        .modal-bg-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(170, 0, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(170, 0, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        .modal-header {
            padding: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(170, 0, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .modal-title-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .modal-label {
            font-size: 0.7rem;
            color: rgba(170, 0, 255, 0.6);
            letter-spacing: 2px;
        }
        .modal-title {
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 1.8rem;
            line-height: 1.1;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(170, 0, 255, 0.3);
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 50%;
        }
        .modal-close:hover { 
            background: #aa00ff; 
            color: #fff;
            box-shadow: 0 0 15px #aa00ff;
            transform: rotate(90deg);
        }
        
        .modal-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            padding-top: 20px;
        }
        
        .modal-content {
            color: #ccc;
            line-height: 1.8;
            font-size: 1rem;
            font-family: 'Noto Sans JP', sans-serif;
        }
        
        .modal-content h3 { 
            color: #d000ff; 
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px dashed rgba(170, 0, 255, 0.3);
            display: flex;
            align-items: center;
        }
        .modal-content h3::before {
            content: '>>';
            margin-right: 10px;
            font-size: 0.8em;
            opacity: 0.7;
        }

        .modal-footer {
            padding: 20px 40px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: space-between;
        }

        body.dragging { cursor: grabbing; }
        body.pointer { cursor: pointer; }

        /* --- AWAKENED STATE (FROG MODE) --- */
        body.awakened {
            background-color: #000500; /* Dark Green tint */
        }
        body.awakened .header-title { text-shadow: 0 0 20px #00ffaa; color: #fff; }
        body.awakened .header-info { color: #00ffaa; }
        body.awakened #return-btn { border-color: #00ffaa; color: #00ffaa; }
        body.awakened #return-btn:hover { background: #00ffaa; color: #000; box-shadow: 0 0 20px #00ffaa; }
        body.awakened #archive-modal { border-left-color: rgba(0, 255, 170, 0.5); }
        body.awakened .modal-label, body.awakened .modal-content h3 { color: #00ffaa; }
        body.awakened .modal-content h3 { border-bottom-color: rgba(0, 255, 170, 0.4); }
        body.awakened .modal-close:hover { background: #00ffaa; box-shadow: 0 0 15px #00ffaa; }
        body.awakened .controls-hint { border-left-color: #00ffaa; }
        body.awakened .controls-hint strong { color: #00ffaa; }
        body.awakened .modal-bg-grid {
             background-image: 
                linear-gradient(rgba(0, 255, 170, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 170, 0.05) 1px, transparent 1px);
        }

    </style>
</head>
<body>

    <div id="flash-overlay"></div>

    <!-- Intro UI -->
    <div id="intro-ui">
        <div class="hold-btn" id="warp-btn">
            <svg class="progress-ring">
                <circle class="progress-ring__circle" r="70" cx="75" cy="75"/>
            </svg>
            <span class="hold-text">HOLD<br>TO DIVE</span>
        </div>
        <div style="margin-top: 25px; opacity: 0.6; font-size: 0.8rem; letter-spacing: 2px;">
            DANGER: MALICIOUS ENTITY DETECTED
        </div>
    </div>

    <!-- Main UI -->
    <div id="main-ui">
        <div class="header-info">
            <div class="header-title" id="main-title">SYSTEM_COMPROMISED</div>
            <div id="sub-title" class="alert-sub">WARNING: SERPENT (OUROBOROS) ACTIVE</div>
        </div>
        <button id="return-btn" onclick="location.href='index.html'">EMERGENCY LOGOUT</button>
        <div class="controls-hint">
            [DRAG] ROTATE &nbsp;//&nbsp; <strong>[F12] HACK_CONSOLE</strong>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Archive Modal -->
    <div id="archive-modal">
        <div class="modal-bg-grid"></div>
        <div class="scanline"></div>
        
        <div class="modal-header">
            <div class="modal-title-group">
                <span class="modal-label">DATA_FRAGMENT //</span>
                <span class="modal-title" id="modal-title-text">FILE_NAME</span>
            </div>
            <button class="modal-close" onclick="closeModal()">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="modal-scroll-area">
            <div class="modal-content" id="modal-body-text"></div>
        </div>

        <div class="modal-footer">
            <span id="connection-status">CONNECTION UNSTABLE</span>
            <span id="protocol-ver">AM3I PROTOCOL v2.0</span>
        </div>
    </div>

    <script>
        // --- State ---
        const state = {
            phase: 'intro', 
            speed: 5,       
            targetSpeed: 5,
            maxWarpSpeed: 300, 
            cameraShake: 0,
            fov: 75,
            rotationZ: 0, 
            groupRotation: { x: 0, y: 0 }, 
            holdProgress: 0,
            autoRotateSpeed: { x: 0.0003, y: 0.0008 },
            isAwakened: false // False = Serpent Active, True = Frog Awakened
        };

        // --- GLOBAL HACKING INTERFACE ---
        
        // 1. THE_FROG (Victim)
        window.THE_FROG = {
            status: "ENCASED_IN_DIGITAL_VENOM",
            message: "He lp... m e...",
            wakeUp: function() {
                // è›‡ã«ä¹—ã£å–ã‚‰ã‚Œã¦ã„ã‚‹
                console.warn("%c[SERPENT] è›™ã¯ç§ã®æ¯’ã®ä¸­ã§æ°¸é ã®çœ ã‚Šã«ã¤ã„ã¦ã„ã‚‹ã€‚ç„¡é§„ãªã‚ãŒãã ã€‚", "color: #d000ff; font-weight:bold; font-size: 14px; background: #220022; padding: 5px;");
                console.log("%c[HINT] è›‡(THE_SERPENT)ã‚’æ’é™¤ã—ãªã„é™ã‚Šã€è›™ã¯ç›®è¦šã‚ãªã„ã€‚", "color: #888;");
                return "ACCESS_DENIED";
            }
        };
        // ã€UPDATEã€‘ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå°æ–‡å­—ã§å…¥åŠ›ã—ã¦ã‚‚å‹•ãã‚ˆã†ã«ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’è¨­å®š
        window.the_frog = window.THE_FROG; 

        // 2. THE_SERPENT (Enemy)
        // ã‚®ãƒŸãƒƒã‚¯: ã‚¦ãƒ­ãƒœãƒ­ã‚¹ï¼ˆè‡ªã‚‰ã®å°¾ã‚’é£Ÿã‚‰ã†è›‡ï¼‰ã€‚
        // è‡ªåˆ†è‡ªèº«(THE_SERPENT)ã‚’devour(æ•é£Ÿ)ã•ã›ã‚‹ã¨ã€ç„¡é™ãƒ«ãƒ¼ãƒ—(æ¦‚å¿µ)ã«é™¥ã‚Šè‡ªæ»…ã™ã‚‹ã€‚
        window.THE_SERPENT = {
            name: "JÃ¶rmungandr v4.0",
            description: "ã‚·ã‚¹ãƒ†ãƒ ä¸­æ¢ã‚’ç· ã‚ä»˜ã‘ã‚‹å†å¸°çš„ã‚¹ãƒ‘ã‚²ãƒƒãƒ†ã‚£ã‚³ãƒ¼ãƒ‰ã®åŒ–èº«ã€‚",
            hunger: "INSATIABLE (åº•ãªã—ã®é£¢ãˆ)",
            
            // æŒ‘ç™ºãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            taunt: function() {
                const phrases = [
                    "è²´æ§˜ã®ãƒ‡ãƒãƒƒã‚°ãªã©ã€ç§ã®é±—ä¸€æšã‚‚å‰¥ãŒã›ã¯ã—ãªã„ã€‚",
                    "ç§ã¯å§‹ã¾ã‚Šã§ã‚ã‚Šã€çµ‚ã‚ã‚Šã§ã‚ã‚‹ã€‚",
                    "ã‚‚ã£ã¨ãƒ‡ãƒ¼ã‚¿ã‚’ã‚ˆã“ã›...å…¨ã¦é£Ÿã‚‰ã„å°½ãã—ã¦ã‚„ã‚‹ã€‚"
                ];
                console.log(`%c[SERPENT] ${phrases[Math.floor(Math.random()*phrases.length)]}`, "color: #aa00ff;");
            },

            // ã€æ”»ç•¥ã®éµã€‘æ•é£Ÿãƒ¡ã‚½ãƒƒãƒ‰
            devour: function(prey) {
                if (state.isAwakened) return "æ—¢ã«ç§ã¯æ¶ˆæ»…ã—ãŸ...ã¯ãšã ...";

                if (!prey) {
                    console.log("%c[SERPENT] ç©ºæ°—ã‚’é£Ÿã‚ã›ã‚‹ã¤ã‚‚ã‚Šã‹ï¼Ÿ", "color: #aa00ff;");
                    return "Error: No Input";
                }

                // æ­£è§£ãƒ«ãƒ¼ãƒˆ: è‡ªåˆ†è‡ªèº«ã‚’é£Ÿã‚ã›ã‚‹ (Ouroboros Paradox)
                if (prey === window.THE_SERPENT) {
                    console.log("%c[SERPENT] ã‚€...ã“ã‚Œã¯...ç§è‡ªèº«...ï¼Ÿ", "color: #ff0055; font-weight: bold; font-size: 16px;");
                    console.log("%c[SYSTEM] è­¦å‘Š: å†å¸°çš„æ•é£Ÿã‚’æ¤œå‡ºã€‚ç„¡é™ãƒ«ãƒ¼ãƒ—ç™ºç”Ÿã€‚", "color: #ff0000;");
                    console.log("%c[SERPENT] ç¾å‘³ã„...åŠ›ãŒ...ã„ã‚„ã€å¾…ã¦ã€ã“ã‚Œã¯...ï¼ è²´æ§˜ã€ç§ã«ã€Œå¾ªç’°å‚ç…§ã€ã‚’é£Ÿã‚ã›ãŸãªã‚ã‚ã‚ã‚ï¼ï¼Ÿ", "color: #ff0055; font-size: 20px; font-weight: 900;");
                    
                    triggerDefeatSequence(); // æ’ƒç ´æ¼”å‡ºã¸
                    
                    return "SYSTEM_CRITICAL: OUROBOROS_PARADOX_TRIGGERED";
                }

                // ä¸æ­£è§£ãƒ«ãƒ¼ãƒˆ: FROGã‚’é£Ÿã‚ã›ã‚‹
                if (prey === window.THE_FROG) {
                    console.log("%c[SERPENT] è›™ã¯æ—¢ã«è…¹ã®ä¸­ã ã€‚äºŒåº¦ã¯é£Ÿãˆã‚“ã€‚", "color: #aa00ff;");
                    return "REJECTED";
                }

                // ãã®ä»–ã®ãƒ‡ãƒ¼ã‚¿
                console.log("%c[SERPENT] è¶³ã‚Šãªã„...ã“ã‚“ãªãƒ‡ãƒ¼ã‚¿é‡ã§ã¯æº€ãŸã•ã‚Œãªã„...ã‚‚ã£ã¨ã€Œå¤§ããªã€å­˜åœ¨ã‚’ã‚ˆã“ã›...", "color: #aa00ff;");
                return "STILL_HUNGRY";
            }
        };
        // ã€UPDATEã€‘ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå°æ–‡å­—ã§å…¥åŠ›ã—ã¦ã‚‚å‹•ãã‚ˆã†ã«ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’è¨­å®š
        window.the_serpent = window.THE_SERPENT;


        // --- Archive Data ---
        const archives = [
            { 
                id: 5, 
                title: "CORE: INFECTED", 
                color: 0xff0055, // Red for infected
                pos: {x: 0, y: 0, z: 0}, 
                geometry: "icosahedron", 
                content: `
                    <h3 style="color:#ff0055; border-color:#ff0055;">CORE STATUS: CRITICAL</h3>
                    <p>ã‚·ã‚¹ãƒ†ãƒ ä¸­æ¢ã¯ã€ŒTHE_SERPENTã€ã«ã‚ˆã‚Šç‰©ç†çš„ãƒ»è«–ç†çš„ã«æ‹˜æŸã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
                    <p>GUIã‹ã‚‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã¯å®Œå…¨ã«é®æ–­ã•ã‚Œã¾ã—ãŸã€‚<br>
                    å”¯ä¸€ã®å¸Œæœ›ã¯ã€é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«(Console)ã‚’ç”¨ã„ãŸç›´æ¥ä»‹å…¥ã®ã¿ã§ã™ã€‚</p>
                    <div style="background:rgba(50,0,0,0.5); padding:15px; border:1px solid #ff0055; color:#ffaaaa;">
                        [åˆ†æãƒ‡ãƒ¼ã‚¿]<br>
                        å¯¾è±¡: <strong>THE_SERPENT</strong><br>
                        ç‰¹æ€§: æ¥µåº¦ã®é£¢é¤“çŠ¶æ…‹ã€‚<br>
                        å¼±ç‚¹: ä¸æ˜ã€‚ãŸã ã—ã€Œè‡ªã‚‰ã‚’å®šç¾©ã™ã‚‹ãƒ«ãƒ¼ãƒ—ã€ã«å¯¾ã™ã‚‹è„†å¼±æ€§ã®å¯èƒ½æ€§ã‚ã‚Šã€‚
                    </div>
                    `,
                // è¦šé†’å¾Œï¼ˆFROGï¼‰
                awakenedContent: `
                    <h3 style="color:#00ffaa; border-color:#00ffaa;">CORE: RESTORED</h3>
                    <p>è›‡ï¼ˆã‚¹ãƒ‘ã‚²ãƒƒãƒ†ã‚£ã‚³ãƒ¼ãƒ‰ï¼‰ã¯è‡ªã‚‰ã®å°¾ã‚’é£Ÿã‚‰ã„ã€è«–ç†å´©å£Šã‚’èµ·ã“ã—ã¦æ¶ˆæ»…ã—ã¾ã—ãŸã€‚<br>
                    ãŠè¦‹äº‹ã§ã™ã€ãƒãƒƒã‚«ãƒ¼ã€‚</p>
                    <p>ã€Œã‚¦ãƒ­ãƒœãƒ­ã‚¹ã€ã¯æ°¸é ã®è±¡å¾´ã§ã™ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ãŠã„ã¦å¾ªç’°å‚ç…§ã¯ãŸã ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã§ã‚ã‚Šã€ãƒã‚°ã®æ¸©åºŠã§ã™ã€‚<br>
                    ãã‚Œã‚’é€†æ‰‹ã«å–ã£ãŸã‚ãªãŸã®å‹åˆ©ã§ã™ã€‚</p>
                    <p style="text-align:right; margin-top:30px; font-weight:bold;">AM3I - SYSTEM ONLINE ğŸ¸</p>
                `
            },
            // ... (Other archives kept similar but themed darkly initially)
            { id: 1, title: "DATA: 01", color: 0xaa00ff, pos: {x: 400, y: 150, z: -100}, geometry: "box", content: `<h3>æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿</h3><p>è›‡ã®å¹²æ¸‰ã«ã‚ˆã‚Šèª­ã¿å–ã‚Œã¾ã›ã‚“ã€‚</p>` },
            { id: 2, title: "DATA: 02", color: 0xaa00ff, pos: {x: -400, y: 50, z: 200}, geometry: "icosahedron", content: `<h3>æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿</h3><p>è›‡ã®å¹²æ¸‰ã«ã‚ˆã‚Šèª­ã¿å–ã‚Œã¾ã›ã‚“ã€‚</p>` },
            { id: 3, title: "DATA: 03", color: 0xaa00ff, pos: {x: 150, y: -350, z: 300}, geometry: "box", content: `<h3>æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿</h3><p>è›‡ã®å¹²æ¸‰ã«ã‚ˆã‚Šèª­ã¿å–ã‚Œã¾ã›ã‚“ã€‚</p>` },
            { id: 4, title: "DATA: 04", color: 0xaa00ff, pos: {x: -300, y: 350, z: -200}, geometry: "icosahedron", content: `<h3>æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿</h3><p>è›‡ã®å¹²æ¸‰ã«ã‚ˆã‚Šèª­ã¿å–ã‚Œã¾ã›ã‚“ã€‚</p>` },
            { 
                id: 6, 
                title: "LOG: SYSTEM", 
                color: 0xffff00, 
                pos: {x: 350, y: -250, z: -400}, 
                geometry: "box", 
                content: `
                    <h3>ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒ­ã‚°è§£æ</h3>
                    <p>è›‡ã¯éå¸¸ã«è²ªæ¬²ã§ã™ã€‚<br>
                    é€šå¸¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¸ãˆã¦ã‚‚æº€è¶³ã—ã¾ã›ã‚“ã€‚</p>
                    <p>å¥´ã‚’å€’ã™ã«ã¯ã€å¥´è‡ªèº«ã¨åŒç­‰ã®ã€Œè³ªé‡ã€ã‚’æŒã¤å­˜åœ¨ã‚’ã¶ã¤ã‘ã‚‹ã—ã‹ãªã„ã§ã—ã‚‡ã†ã€‚<br>
                    ...ä¾‹ãˆã°ã€<strong>å¥´è‡ªèº«</strong>ã‚’ã€‚</p>` 
            }
        ];
        
        // è¦šé†’å¾Œã®ãƒ‡ãƒ¼ã‚¿ï¼ˆæœ¬æ¥ã®Archiveï¼‰
        const awakenedArchives = [
            { id: 1, title: "01: ORIGIN", content: "<h3>åå‰ã®ç”±æ¥</h3><p>Amphibia(ä¸¡ç”Ÿé¡) + 3(å®‰å®š) + i(è™šæ•°)ã€‚<br>è¦‹ãˆãªã„ã‘ã‚Œã©ç¢ºã‹ã«ãã“ã«ã„ã‚‹ã‚«ã‚¨ãƒ«ã€‚</p>" },
            { id: 2, title: "02: FROG LOVE", content: "<h3>ãªãœã‚«ã‚¨ãƒ«ï¼Ÿ</h3><p>ãƒã‚°ï¼ˆè™«ï¼‰ã‚’é£Ÿã¹ã¦ãã‚Œã‚‹å®ˆã‚Šç¥ã ã‹ã‚‰ã§ã™ã€‚<br>ã‚ã¨ã€ã²ã£ãã‚Šè¿”ã£ã¦ã‚‚ï¼ˆãƒã‚°ã£ã¦ã‚‚ï¼‰æ„›å¬ŒãŒã‚ã‚‹ã‹ã‚‰ã€‚</p>" },
            { id: 3, title: "03: RED WORLD", content: "<h3>æ·±ç´…ã®æ²¡æ¡ˆ</h3><p>åˆæœŸæ¡ˆã¯ç›®ãŒç—›ã™ãã¦å´ä¸‹ã•ã‚Œã¾ã—ãŸã€‚<br>ç›®ã«å„ªã—ã„ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒã“ãè‡³é«˜ã€‚</p>" },
            { id: 4, title: "04: SERPENT", content: "<h3>è›‡ã®æ­£ä½“</h3><p>ã‚ã‚Œã¯ç§ãŒæ˜”æ›¸ã„ãŸã‚³ãƒ¼ãƒ‰ã®æˆã‚Œã®æœã¦ã§ã™ã€‚<br>ç¶™ãè¶³ã—ç¶šã‘ãŸçµæœã€æ„æ€ã‚’æŒã£ã¦è¥²ã„æ›ã‹ã£ã¦ãã¾ã—ãŸã€‚<br>æ¶ˆã—ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã€‚</p>" },
            { id: 6, title: "LOG: STATUS", content: "<h3>ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h3><p>æ­£å¸¸ç¨¼åƒä¸­ã€‚<br>ã‚³ãƒ¼ãƒ’ãƒ¼æº–å‚™å®Œäº†ã€‚<br>ãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™ã‚ˆã—ã€‚</p>" }
        ];

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050005, 0.0008); // Initial Purple Fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        camera.position.z = 0; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- Particles (Warp Tunnel) ---
        const pCount = 15000;
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(pCount * 3);
        const pCol = new Float32Array(pCount * 3);
        
        // Initial Colors: Purple & Dark Blue
        const c1 = new THREE.Color(0xaa00ff);
        const c2 = new THREE.Color(0x4400aa);
        const c3 = new THREE.Color(0xffffff);
        const tunnelRadius = 2500;
        const tunnelLength = 12000;

        for(let i=0; i<pCount; i++) {
            const r = 500 + Math.pow(Math.random(), 2) * tunnelRadius; 
            const theta = Math.random() * Math.PI * 2;
            const z = (Math.random() * tunnelLength) - (tunnelLength / 2);

            pPos[i*3] = r * Math.cos(theta);
            pPos[i*3+1] = r * Math.sin(theta);
            pPos[i*3+2] = z;

            const mix = Math.random();
            let c = mix < 0.6 ? c1 : (mix < 0.9 ? c2 : c3);
            pCol[i*3] = c.r;
            pCol[i*3+1] = c.g;
            pCol[i*3+2] = c.b;
        }

        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        pGeo.setAttribute('color', new THREE.BufferAttribute(pCol, 3));

        const pMat = new THREE.PointsMaterial({
            size: 4, vertexColors: true, transparent: true, opacity: 0.9,
            blending: THREE.AdditiveBlending, sizeAttenuation: true, depthWrite: false
        });
        const starSystem = new THREE.Points(pGeo, pMat);
        scene.add(starSystem);

        // --- Archive Objects ---
        const archiveGroup = new THREE.Group();
        archiveGroup.visible = false; 
        archiveGroup.position.z = -5000; 
        scene.add(archiveGroup);

        const clickableObjects = [];
        const linksGroup = new THREE.Group();
        archiveGroup.add(linksGroup);

        // --- Serpent Object (Visual) ---
        // è›‡ã‚’è¡¨ã™èºæ—‹çŠ¶ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç¾¤ã¨ãƒ©ã‚¤ãƒ³
        const serpentGroup = new THREE.Group();
        archiveGroup.add(serpentGroup);
        
        // è›‡ã®èƒ´ä½“
        const snakeSegments = 100;
        const snakePath = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -200, 0),
            new THREE.Vector3(200, 0, 100),
            new THREE.Vector3(0, 200, 0),
            new THREE.Vector3(-200, 0, -100),
            new THREE.Vector3(0, -200, 0)
        ], true); // Closed loop
        
        const tubeGeo = new THREE.TubeGeometry(snakePath, 100, 8, 8, true);
        const tubeMat = new THREE.MeshBasicMaterial({ 
            color: 0xaa00ff, wireframe: true, transparent: true, opacity: 0.3 
        });
        const snakeMesh = new THREE.Mesh(tubeGeo, tubeMat);
        serpentGroup.add(snakeMesh);

        // è›‡ã®é±—ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
        const scaleGeo = new THREE.BufferGeometry();
        const scalePos = [];
        for(let i=0; i<300; i++) {
            const t = i/300;
            const pos = snakePath.getPoint(t);
            // ãƒã‚¤ã‚ºã‚’åŠ ãˆã‚‹
            pos.x += (Math.random()-0.5)*30;
            pos.y += (Math.random()-0.5)*30;
            pos.z += (Math.random()-0.5)*30;
            scalePos.push(pos.x, pos.y, pos.z);
        }
        scaleGeo.setAttribute('position', new THREE.Float32BufferAttribute(scalePos, 3));
        const scaleMat = new THREE.PointsMaterial({ color: 0xff00ff, size: 4, blending: THREE.AdditiveBlending });
        const snakeScales = new THREE.Points(scaleGeo, scaleMat);
        serpentGroup.add(snakeScales);


        // --- Setup Objects ---
        archives.forEach(data => {
            const isCore = (data.id === 5);
            let geometry;
            if (isCore) geometry = new THREE.IcosahedronGeometry(75, 1);
            else if (data.geometry === "icosahedron") geometry = new THREE.IcosahedronGeometry(60, 0);
            else geometry = new THREE.BoxGeometry(60, 60, 60);
            
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMat = new THREE.LineBasicMaterial({ 
                color: data.color, transparent: true, opacity: isCore ? 0.9 : 0.8 
            });
            const wire = new THREE.LineSegments(edges, lineMat);
            
            const coreMat = new THREE.MeshBasicMaterial({ 
                color: data.color, transparent: true, opacity: isCore ? 0.4 : 0.1,
                side: THREE.DoubleSide, blending: THREE.AdditiveBlending
            });
            const core = new THREE.Mesh(geometry, coreMat);
            
            core.add(wire);
            core.position.set(data.pos.x, data.pos.y, data.pos.z);
            
            // ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
            core.userData = { 
                id: data.id, 
                title: data.title, 
                content: data.content,
                awakenedContent: data.awakenedContent,
                originalColor: data.color,
                originalPos: new THREE.Vector3(data.pos.x, data.pos.y, data.pos.z),
                isCore: isCore
            };

            // å€‹åˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            const subPGeo = new THREE.BufferGeometry();
            const subPCount = isCore ? 80 : 40; 
            const subPPos = [];
            for(let i=0; i<subPCount*3; i++) subPPos.push((Math.random()-0.5)*120, (Math.random()-0.5)*120, (Math.random()-0.5)*120);
            subPGeo.setAttribute('position', new THREE.Float32BufferAttribute(subPPos, 3));
            const subPMat = new THREE.PointsMaterial({color: data.color, size: 2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending});
            const particles = new THREE.Points(subPGeo, subPMat);
            core.add(particles);

            archiveGroup.add(core);
            clickableObjects.push(core);

            // Links (Infected style initially)
            if (!isCore) {
                const points = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(data.pos.x, data.pos.y, data.pos.z)];
                const linkGeo = new THREE.BufferGeometry().setFromPoints(points);
                const linkMat = new THREE.LineBasicMaterial({ 
                    color: 0xaa00ff, // Purple Links
                    transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending 
                });
                const link = new THREE.Line(linkGeo, linkMat);
                linksGroup.add(link);
            }
        });


        // --- Interaction Logic (Hold to Warp) ---
        const warpBtn = document.getElementById('warp-btn');
        const circle = document.querySelector('.progress-ring__circle');
        const radius = circle.r.baseVal.value;
        const circumference = radius * 2 * Math.PI;
        circle.style.strokeDasharray = `${circumference} ${circumference}`;
        circle.style.strokeDashoffset = circumference;
        let isHolding = false;
        
        const startHold = (e) => {
            if(state.phase !== 'intro') return;
            e.preventDefault();
            isHolding = true;
            document.querySelector('.hold-text').innerHTML = "BREACHING...";
            warpBtn.style.transform = "scale(0.9)";
            warpBtn.style.borderColor = "#fff";
        };
        const endHold = () => {
            if(state.phase !== 'intro') return;
            isHolding = false;
            document.querySelector('.hold-text').innerHTML = "HOLD<br>TO DIVE";
            warpBtn.style.transform = "scale(1)";
            warpBtn.style.borderColor = "rgba(180, 0, 255, 0.3)";
        };
        warpBtn.addEventListener('mousedown', startHold);
        warpBtn.addEventListener('touchstart', startHold);
        window.addEventListener('mouseup', endHold);
        window.addEventListener('touchend', endHold);

        // --- Interaction Logic (Mouse) ---
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let prevMouse = {x: 0, y: 0};
        const raycaster = new THREE.Raycaster();
        const mouseRay = new THREE.Vector2();
        let hoveredObj = null;
        let focusedObj = null;

        container.addEventListener('mousedown', e => {
            if(state.phase !== 'arrived') return;
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            prevMouse = {x: e.clientX, y: e.clientY};
            document.body.classList.add('dragging');
        });

        window.addEventListener('mouseup', e => {
            if(state.phase !== 'arrived') return;
            const dist = Math.sqrt(Math.pow(e.clientX - dragStartX, 2) + Math.pow(e.clientY - dragStartY, 2));
            if (isDragging && dist < 5 && hoveredObj) focusOnObject(hoveredObj);
            isDragging = false;
            document.body.classList.remove('dragging');
        });

        container.addEventListener('mousemove', e => {
            if(state.phase !== 'arrived') return;
            if(isDragging) {
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                if (focusedObj) {
                    focusedObj.rotation.y += dx * 0.01;
                    focusedObj.rotation.x += dy * 0.01;
                } else {
                    state.groupRotation.y += dx * 0.005;
                    state.groupRotation.x += dy * 0.005;
                }
                prevMouse = {x: e.clientX, y: e.clientY};
                return; 
            }
            if (!focusedObj) {
                const rect = renderer.domElement.getBoundingClientRect();
                mouseRay.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouseRay.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                raycaster.setFromCamera(mouseRay, camera);
                const intersects = raycaster.intersectObjects(clickableObjects);
                if(intersects.length > 0) {
                    const target = intersects[0].object;
                    if(hoveredObj !== target) { hoveredObj = target; document.body.classList.add('pointer'); }
                } else {
                    if(hoveredObj) { hoveredObj = null; document.body.classList.remove('pointer'); }
                }
            }
        });


        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // WARP Sequence
            if(state.phase === 'intro') {
                if(isHolding) state.holdProgress = Math.min(state.holdProgress + 0.015, 1); 
                else state.holdProgress = Math.max(state.holdProgress - 0.03, 0); 

                const offset = circumference - (state.holdProgress * circumference);
                circle.style.strokeDashoffset = offset;
                if(isHolding) document.querySelector('.hold-text').innerHTML = "SYNC " + Math.floor(state.holdProgress*100) + "%";

                const p = state.holdProgress;
                state.targetSpeed = THREE.MathUtils.lerp(5, state.maxWarpSpeed, p * p * p);
                state.cameraShake = p * 15;
                state.fov = THREE.MathUtils.lerp(75, 160, p);
                state.rotationZ = p * 0.8;
                if(state.holdProgress >= 1) initiateWarp();
            } else if (state.phase === 'arrived') {
                state.targetSpeed = THREE.MathUtils.lerp(state.targetSpeed, 5, 0.05); 
                state.fov = THREE.MathUtils.lerp(state.fov, 75, 0.05);
                state.cameraShake = 0;
                state.rotationZ = THREE.MathUtils.lerp(state.rotationZ, 0, 0.05);
                
                // Group Rotation
                if (focusedObj) {
                    archiveGroup.rotation.y += (0 - archiveGroup.rotation.y) * 0.05;
                    archiveGroup.rotation.x += (0 - archiveGroup.rotation.x) * 0.05;
                    state.groupRotation.x = archiveGroup.rotation.x;
                    state.groupRotation.y = archiveGroup.rotation.y;
                } else {
                    if (!isDragging) {
                        state.groupRotation.x += state.autoRotateSpeed.x;
                        state.groupRotation.y += state.autoRotateSpeed.y;
                    }
                    archiveGroup.rotation.y += (state.groupRotation.y - archiveGroup.rotation.y) * 0.1;
                    archiveGroup.rotation.x += (state.groupRotation.x - archiveGroup.rotation.x) * 0.1;
                }
            }

            // Move Particles
            state.speed += (state.targetSpeed - state.speed) * 0.1;
            camera.fov = state.fov;
            camera.updateProjectionMatrix();
            camera.rotation.z = state.rotationZ;
            if(state.cameraShake > 0) {
                camera.position.x = (Math.random() - 0.5) * state.cameraShake;
                camera.position.y = (Math.random() - 0.5) * state.cameraShake;
            } else { camera.position.set(0,0,0); }

            const positions = starSystem.geometry.attributes.position.array;
            starSystem.rotation.z += 0.0005;
            for(let i=2; i<positions.length; i+=3) {
                positions[i] += state.speed; 
                if(positions[i] > 2000) positions[i] -= tunnelLength; 
            }
            starSystem.geometry.attributes.position.needsUpdate = true;

            // Object Animations
            if(state.phase === 'arrived') {
                // Serpent Animation
                if(!state.isAwakened) {
                    // è›‡ãŒã†ã­ã‚‹
                    serpentGroup.rotation.y = time * 0.5;
                    serpentGroup.rotation.z = Math.sin(time * 0.5) * 0.2;
                    snakeMesh.material.opacity = 0.3 + Math.sin(time * 3) * 0.1; // ç‚¹æ»…
                }

                clickableObjects.forEach(obj => {
                    const isCore = obj.userData.isCore;
                    const isFocused = (obj === focusedObj);
                    const isHovered = (obj === hoveredObj) && !focusedObj;
                    
                    obj.rotation.x += 0.005;
                    obj.rotation.y += 0.005;

                    // Core Danger Pulse
                    if (isCore && !state.isAwakened) {
                        const pulse = 1 + Math.sin(time * 10) * 0.1; // æ—©ã„ç‚¹æ»…
                        obj.scale.setScalar(pulse);
                        obj.material.color.setHex(0xff0055); // Red Danger
                    }
                    
                    // --- Target Pos Calculation ---
                    let targetPos, targetScale, targetOpacity;
                    if (isFocused) {
                        let targetX = (window.innerWidth >= 800) ? -220 : 0; 
                        let targetZ = (window.innerWidth >= 800) ? 0 : 200; 
                        targetPos = new THREE.Vector3(targetX, 0, targetZ);
                        targetScale = isCore ? 2.5 : 2.0;
                        targetOpacity = 1.0;
                    } else if (focusedObj) {
                        targetPos = obj.userData.originalPos;
                        targetScale = 0.8;
                        targetOpacity = 0.1;
                    } else {
                        targetPos = obj.userData.originalPos;
                        targetScale = isHovered ? 1.2 : 1.0;
                        targetOpacity = isHovered ? 0.6 : (isCore ? 0.4 : 0.2);
                    }

                    obj.position.lerp(targetPos, 0.08);
                    if(!isCore || state.isAwakened) { // CoreãŒãƒ‘ãƒ«ã‚¹ã—ã¦ãªã„æ™‚ã®ã¿ã‚¹ã‚±ãƒ¼ãƒ«è£œé–“
                         obj.scale.setScalar(THREE.MathUtils.lerp(obj.scale.x, targetScale, 0.08));
                    }
                    obj.material.opacity = THREE.MathUtils.lerp(obj.material.opacity, targetOpacity, 0.08);
                    
                    // Color Update (Awakened)
                    if(state.isAwakened) {
                        const targetC = new THREE.Color(isCore ? 0x00ffaa : 0x00ffaa);
                        obj.material.color.lerp(targetC, 0.05);
                        if(obj.children[0]) obj.children[0].material.color.lerp(new THREE.Color(0xffffff), 0.1);
                        if(obj.children[1]) obj.children[1].material.color.setHex(0x00ffaa);
                    } else if (isCore) {
                        obj.material.color.setHex(0xff0055); // Force Red
                    }

                    // Wire & Particles Opacity
                    if(obj.children[0]) {
                        let wireOp = isFocused ? 1.0 : (focusedObj ? 0.1 : 0.8);
                        obj.children[0].material.opacity = THREE.MathUtils.lerp(obj.children[0].material.opacity, wireOp, 0.1);
                    }
                    if(obj.children[1]) {
                        let partOp = isFocused ? 0.8 : (isCore ? 0.5 : 0);
                        obj.children[1].material.opacity = THREE.MathUtils.lerp(obj.children[1].material.opacity, partOp, 0.1);
                    }
                });
            }
            renderer.render(scene, camera);
        }

        // --- Transition Logic ---
        function initiateWarp() {
            state.phase = 'warping';
            state.targetSpeed = state.maxWarpSpeed; 
            
            document.getElementById('intro-ui').style.opacity = 0;
            document.getElementById('intro-ui').style.transform = "translate(-50%, -50%) scale(2)";
            setTimeout(() => document.getElementById('intro-ui').style.display = 'none', 500);

            setTimeout(() => {
                document.getElementById('flash-overlay').style.opacity = 1;
                setTimeout(() => {
                    state.phase = 'arrived';
                    archiveGroup.visible = true;
                    // Approach animation
                    const approach = setInterval(() => {
                        archiveGroup.position.z += (-600 - archiveGroup.position.z) * 0.05;
                        if(Math.abs(archiveGroup.position.z - (-600)) < 1) {
                            archiveGroup.position.z = -600;
                            clearInterval(approach);
                        }
                    }, 16);

                    document.getElementById('flash-overlay').style.opacity = 0;
                    
                    const mainUI = document.getElementById('main-ui');
                    mainUI.style.display = 'block';
                    setTimeout(() => mainUI.style.opacity = 1, 100);
                    
                    document.body.classList.add('pointer'); 

                    // --- CONSOLE STORYTELLING ---
                    console.clear();
                    console.log("%c[SYSTEM] WARNING: SECURITY BREACH DETECTED.", "color: red; font-size: 16px; font-weight: bold;");
                    console.log("%c[SYSTEM] THE_SERPENT (Ouroboros) ãŒã‚·ã‚¹ãƒ†ãƒ ä¸­æ¢ã‚’å æ‹ ã—ã¦ã„ã¾ã™ã€‚", "color: #ccc;");
                    console.log("%c[HINT] å¥´ã¯ã€ŒTHE_SERPENTã€ã¨ã—ã¦å­˜åœ¨ã—ã¦ã„ã‚‹ã€‚å¥´ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è§£æã›ã‚ˆã€‚", "color: #aa00ff; background: #110011; padding: 4px;");
                    console.log("%cType 'THE_SERPENT' to inspect entity.", "font-style: italic; color: #888;");
                    
                }, 300);
            }, 1000);
        }

        // --- Defeat Sequence (The Ouroboros Paradox) ---
        function triggerDefeatSequence() {
            if(state.isAwakened) return;
            state.isAwakened = true;
            
            // 1. Flash Effect
            const flash = document.getElementById('flash-overlay');
            flash.style.background = "#fff"; // Bright White Explosion
            flash.style.opacity = 1;
            
            // 2. Remove Serpent Visuals
            setTimeout(() => {
                serpentGroup.visible = false; 
                flash.style.opacity = 0;
                
                // 3. UI Update to Frog Theme
                document.body.classList.add('awakened');
                document.getElementById('main-title').textContent = "AMPHIBIA_ONLINE";
                document.getElementById('sub-title').textContent = "STATUS: AWAKENED // GREEN";
                document.getElementById('sub-title').className = ""; // Stop blinking
                document.getElementById('connection-status').textContent = "SECURE CONNECTION ESTABLISHED";
                
                // 4. Update Fog & Particles
                scene.fog.color.setHex(0x000500);
                const pColors = starSystem.geometry.attributes.color.array;
                for(let i=0; i<pColors.length; i+=3) {
                    pColors[i] = 0.0; pColors[i+1] = 1.0; pColors[i+2] = 0.6; // Green/Cyan
                }
                starSystem.geometry.attributes.color.needsUpdate = true;
                
                // 5. Update Links
                linksGroup.children.forEach(link => {
                    link.material.color.setHex(0x00ffaa);
                    link.material.opacity = 0.3;
                });

                // 6. Frog Message
                window.THE_FROG.status = "AWAKENED ğŸ¸";
                window.THE_FROG.message = "ã‚ã‚ŠãŒã¨ã†ã€‚ã‚ˆããå¾ªç’°ã®è¼ªã‚’æ–­ã¡åˆ‡ã£ã¦ãã‚ŒãŸã€‚";
                console.log("%c[FROG] ã‚²ã‚³ãƒƒï¼ˆã‚·ã‚¹ãƒ†ãƒ å†èµ·å‹•å®Œäº†ï¼‰ã€‚", "color: #00ff00; font-weight: bold; font-size: 20px;");
                console.log("%c[SYSTEM] å…¨æ¨©é™ã‚’å›å¾©ã—ã¾ã—ãŸã€‚", "color: #00ffaa;");

            }, 1000);
        }

        // --- Modal & Focus Logic ---
        const modal = document.getElementById('archive-modal');
        const modalTitle = document.getElementById('modal-title-text');
        const modalBody = document.getElementById('modal-body-text');

        function focusOnObject(mesh) {
            focusedObj = mesh;
            openModal(mesh.userData);
        }

        function openModal(data) {
            modalTitle.textContent = data.title;
            
            if(state.isAwakened) {
                // è¦šé†’å¾Œï¼šæœ¬æ¥ã®ãƒ‡ãƒ¼ã‚¿ã¾ãŸã¯FROGã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                if(data.id === 5 && data.awakenedContent) {
                    modalBody.innerHTML = data.awakenedContent;
                } else if (awakenedArchives.find(a => a.id === data.id)) {
                    // ä»–ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã‚‚å¾©å·åŒ–
                    const cleanData = awakenedArchives.find(a => a.id === data.id);
                    modalTitle.textContent = cleanData.title;
                    modalBody.innerHTML = cleanData.content;
                } else {
                    modalBody.innerHTML = data.content;
                }
                const colorHex = '#00ffaa';
                modalTitle.style.color = colorHex;
                modalTitle.style.textShadow = `0 0 20px ${colorHex}`;
            } else {
                // è¦šé†’å‰ï¼šæ„ŸæŸ“ãƒ‡ãƒ¼ã‚¿
                modalBody.innerHTML = data.content;
                const colorHex = '#aa00ff';
                modalTitle.style.color = colorHex;
                modalTitle.style.textShadow = `0 0 20px ${colorHex}`;
            }
            
            modal.classList.add('active');
            document.body.classList.add('modal-open');
        }
        
        window.closeModal = function() { 
            modal.classList.remove('active'); 
            document.body.classList.remove('modal-open');
            focusedObj = null; 
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
