<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyhedra Morph & Truncate</title>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Noto+Sans+JP:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        :root {
            --primary-color: #00e6e6;
            --secondary-color: #003333;
            --accent-color: #ff0055;
            --bg-color: #050505;
            --text-color: #ffffff;
            --glass-bg: rgba(0, 30, 30, 0.85);
            --glow-strong: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
            --glow-soft: 0 0 5px var(--primary-color);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Orbitron', 'Noto Sans JP', sans-serif;
            background-image: 
                linear-gradient(rgba(0, 230, 230, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 230, 230, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        /* Scanline Effect */
        .scanline {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, transparent 50%, rgba(0, 230, 230, 0.02) 51%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
        }

        /* --- Header --- */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem 2rem;
            background: rgba(0, 10, 10, 0.9);
            border-bottom: 2px solid var(--primary-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 20;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 230, 230, 0.2);
        }

        .app-title {
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--primary-color);
            text-shadow: var(--glow-soft);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .back-link {
            color: var(--text-color);
            text-decoration: none;
            font-size: 0.8rem;
            border: 1px solid var(--primary-color);
            padding: 0.5rem 1rem;
            transition: 0.3s;
            background: rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .back-link:hover {
            background: var(--primary-color);
            color: #000;
            box-shadow: var(--glow-soft);
        }

        /* --- UI Container (Top Buttons) --- */
        #ui-container {
            position: absolute;
            top: 80px; /* Below header */
            left: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            pointer-events: none;
            z-index: 10;
        }

        .row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            padding: 0 20px;
        }

        .btn {
            pointer-events: auto;
            background: rgba(0, 20, 20, 0.8);
            border: 1px solid var(--secondary-color);
            color: var(--primary-color);
            padding: 10px 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
            position: relative;
            overflow: hidden;
            min-width: 100px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 8px; height: 8px;
            background: linear-gradient(45deg, transparent 50%, var(--primary-color) 50%);
        }

        .btn:hover:not(:disabled) {
            background: rgba(0, 230, 230, 0.2);
            border-color: var(--primary-color);
            box-shadow: var(--glow-strong);
            transform: translateY(-2px);
            color: #fff;
        }

        .btn.active {
            background: var(--primary-color);
            color: #000;
            border-color: var(--primary-color);
            font-weight: bold;
            box-shadow: var(--glow-strong);
        }

        .btn-action {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }
        
        .btn-action::before {
            background: linear-gradient(45deg, transparent 50%, var(--accent-color) 50%);
        }

        .btn-action:hover:not(:disabled) {
            background: rgba(255, 0, 85, 0.2);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
            color: #fff;
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            border-color: #555;
            color: #888;
        }

        /* --- Controls Panel (Right Side) --- */
        #controls-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            background: var(--glass-bg);
            padding: 20px;
            border: 1px solid var(--primary-color);
            box-shadow: var(--glow-soft);
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 280px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
            border-radius: 4px;
            z-index: 15;
        }
        
        /* Custom Scrollbar */
        #controls-panel::-webkit-scrollbar { width: 5px; }
        #controls-panel::-webkit-scrollbar-track { background: #000; }
        #controls-panel::-webkit-scrollbar-thumb { background: var(--primary-color); }

        .panel-title {
            font-size: 1rem;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border: 1px solid #333;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-label {
            font-size: 0.8rem;
            color: #aaa;
            flex-grow: 1;
        }

        .val-display {
            font-family: 'Orbitron', monospace;
            color: var(--primary-color);
            margin-right: 8px;
            font-size: 0.8rem;
        }

        .reset-btn {
            background: transparent;
            border: 1px solid #555;
            color: #555;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: all 0.2s;
        }
        .reset-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            box-shadow: 0 0 5px var(--primary-color);
        }

        /* Cyberpunk Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 5px 0;
        }

        input[type="range"]:focus { outline: none; }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #111;
            border: 1px solid #333;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid var(--primary-color);
            height: 16px;
            width: 10px;
            background: #000;
            cursor: pointer;
            margin-top: -7px; /* center */
            box-shadow: 0 0 5px var(--primary-color);
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-color);
        }

        /* --- Footer Info --- */
        #info {
            position: absolute;
            bottom: 10px;
            left: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0; left: 0;
        }
    </style>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div class="scanline"></div>

    <header class="header">
        <div class="app-title">
            <i class="fas fa-cube"></i> POLYHEDRA LAB
        </div>
        <a href="./index.html" class="back-link">
            <i class="fas fa-arrow-left"></i> RETURN
        </a>
    </header>

    <div id="ui-container">
        <!-- Shape Selection -->
        <div class="row">
            <button class="btn" onclick="morphTo('tetrahedron', this)">TETRA</button>
            <button class="btn" onclick="morphTo('cube', this)">CUBE</button>
            <button class="btn" onclick="morphTo('octahedron', this)">OCTA</button>
            <button class="btn active" onclick="morphTo('dodecahedron', this)">DODECA</button>
            <button class="btn" onclick="morphTo('icosahedron', this)">ICOSA</button>
        </div>
        <!-- Truncation Actions -->
        <div class="row">
            <button class="btn btn-action" onclick="truncateShape('midpoint')">MIDPOINT CUT</button>
            <button class="btn btn-action" onclick="truncateShape('trisection')">TRI-SECTION CUT</button>
            <button class="btn" id="undo-btn" onclick="undo()" disabled><i class="fas fa-undo"></i> UNDO</button>
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="controls-panel">
        <div class="panel-title"><i class="fas fa-eye"></i> VIEW SETTINGS</div>
        
        <!-- Perspective (FOV) -->
        <div class="control-group">
            <div class="control-header">
                <span class="control-label">FOV (Perspective)</span>
                <span id="fov-val" class="val-display">45째</span>
                <button class="reset-btn" onclick="resetParam('fov')" title="Reset"><i class="fas fa-sync-alt"></i></button>
            </div>
            <input type="range" id="fov-slider" min="1" max="120" step="1" value="45">
        </div>

        <!-- Zoom -->
        <div class="control-group">
            <div class="control-header">
                <span class="control-label">ZOOM LEVEL</span>
                <button class="reset-btn" onclick="resetParam('zoom')" title="Reset"><i class="fas fa-sync-alt"></i></button>
            </div>
            <input type="range" id="zoom-slider" min="0" max="1" step="0.001" value="0.236">
        </div>

        <div class="panel-title" style="margin-top: 10px;"><i class="fas fa-sliders-h"></i> MATERIAL</div>

        <!-- Opacity -->
        <div class="control-group">
            <div class="control-header">
                <span class="control-label">OPACITY</span>
                <span id="opacity-val" class="val-display">0.6</span>
                <button class="reset-btn" onclick="resetParam('opacity')" title="Reset"><i class="fas fa-sync-alt"></i></button>
            </div>
            <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="0.6">
        </div>

        <!-- Roughness -->
        <div class="control-group">
            <div class="control-header">
                <span class="control-label">ROUGHNESS</span>
                <span id="roughness-val" class="val-display">0.2</span>
                <button class="reset-btn" onclick="resetParam('roughness')" title="Reset"><i class="fas fa-sync-alt"></i></button>
            </div>
            <input type="range" id="roughness-slider" min="0" max="1" step="0.05" value="0.2">
        </div>

        <div class="panel-title" style="margin-top: 10px;"><i class="fas fa-microchip"></i> DETAILS</div>

        <!-- Point Size -->
        <div class="control-group">
            <div class="control-header">
                <span class="control-label">PARTICLE SIZE</span>
                <span id="size-val" class="val-display">0.04</span>
                <button class="reset-btn" onclick="resetParam('pointSize')" title="Reset"><i class="fas fa-sync-alt"></i></button>
            </div>
            <input type="range" id="size-slider" min="0" max="0.15" step="0.005" value="0.04">
        </div>

        <!-- Edge Angle -->
        <div class="control-group">
            <div class="control-header">
                <span class="control-label">EDGE THRESHOLD</span>
                <span id="edge-angle-val" class="val-display">10째</span>
                <button class="reset-btn" onclick="resetParam('edgeAngle')" title="Reset"><i class="fas fa-sync-alt"></i></button>
            </div>
            <input type="range" id="edge-angle-slider" min="0.1" max="60" step="0.1" value="10">
        </div>
    </div>

    <div id="canvas-container"></div>
    <div id="info">
        STATUS: ONLINE &nbsp;//&nbsp; DRAG TO ROTATE &nbsp;//&nbsp; SCROLL TO ZOOM
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
        import { ConvexHull } from 'three/addons/math/ConvexHull.js';

        // --- Settings ---
        const scene = new THREE.Scene();
        // Background controlled by CSS, scene background transparent
        // Fog adjusted to match dark theme
        const initialFogDensity = 0.002; 
        scene.fog = new THREE.FogExp2(0x050505, initialFogDensity);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.set(0, 0, 6);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        // Cyberpunk colors for lights
        const pointLight1 = new THREE.PointLight(0x00e6e6, 40, 0); // Cyan
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff0055, 40, 0); // Pink
        pointLight2.position.set(-5, -5, 5);
        scene.add(pointLight2);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 1.0;
        controls.maxDistance = 2000.0;

        // --- Zoom Logic ---
        const MIN_ZOOM_DIST = 1.0;
        const MAX_ZOOM_DIST = 2000.0;
        const ZOOM_LOG_FACTOR = Math.log(MAX_ZOOM_DIST / MIN_ZOOM_DIST);

        function getZoomDistance(sliderValue) {
            return MIN_ZOOM_DIST * Math.exp(sliderValue * ZOOM_LOG_FACTOR);
        }

        function getZoomSliderValue(distance) {
            const d = Math.max(MIN_ZOOM_DIST, Math.min(MAX_ZOOM_DIST, distance));
            return Math.log(d / MIN_ZOOM_DIST) / ZOOM_LOG_FACTOR;
        }

        // --- Constants ---
        const PHI = (1 + Math.sqrt(5)) / 2;

        // --- Geometry Definitions ---
        function normalizePoints(points) {
            return points.map(p => p.normalize());
        }

        const Geometries = {
            tetrahedron: () => normalizePoints([
                new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, -1, -1),
                new THREE.Vector3(-1, 1, -1), new THREE.Vector3(-1, -1, 1)
            ]),
            cube: () => {
                const pts = [];
                for (let x of [-1, 1]) for (let y of [-1, 1]) for (let z of [-1, 1]) pts.push(new THREE.Vector3(x, y, z));
                return normalizePoints(pts);
            },
            octahedron: () => normalizePoints([
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ]),
            icosahedron: () => {
                const pts = [];
                for (let s1 of [-1, 1]) for (let s2 of [-1, 1]) {
                    pts.push(new THREE.Vector3(0, s1, s2 * PHI));
                    pts.push(new THREE.Vector3(s1, s2 * PHI, 0));
                    pts.push(new THREE.Vector3(s2 * PHI, 0, s1));
                }
                return normalizePoints(pts);
            },
            dodecahedron: () => {
                const pts = [];
                for (let x of [-1, 1]) for (let y of [-1, 1]) for (let z of [-1, 1]) pts.push(new THREE.Vector3(x, y, z));
                const invPhi = 1 / PHI;
                for (let s1 of [-1, 1]) for (let s2 of [-1, 1]) {
                    pts.push(new THREE.Vector3(0, s1 * invPhi, s2 * PHI));
                    pts.push(new THREE.Vector3(s1 * invPhi, s2 * PHI, 0));
                    pts.push(new THREE.Vector3(s2 * PHI, 0, s1 * invPhi));
                }
                return normalizePoints(pts);
            }
        };

        // --- System State ---
        let particles = [];
        let targets = [];
        let pointMeshes = [];
        let history = [];

        // Groups
        const shapeGroup = new THREE.Group();
        scene.add(shapeGroup);

        // Materials (Cyberpunk Style)
        const material = new THREE.MeshPhysicalMaterial({
            color: 0x00e6e6, // Cyan base
            emissive: 0x002222,
            metalness: 0.2, 
            roughness: 0.2, 
            transmission: 0.6,
            thickness: 1.0,
            side: THREE.DoubleSide,
            flatShading: true,
            transparent: true,
            opacity: 0.6
        });
        const mainMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
        shapeGroup.add(mainMesh);

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0.4 });
        const wireframeMesh = new THREE.LineSegments(new THREE.BufferGeometry(), lineMaterial);
        shapeGroup.add(wireframeMesh);

        const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0xff0055 }); // Pink dots

        // --- Defaults ---
        const defaults = {
            fov: 45,
            zoom: 0.236,
            opacity: 0.6,
            roughness: 0.2,
            pointSize: 0.04,
            edgeAngle: 10
        };

        let currentPointSize = defaults.pointSize;
        let currentEdgeThreshold = defaults.edgeAngle;

        // --- Reset Function ---
        window.resetParam = (param) => {
            const val = defaults[param];
            let sliderId = '';
            
            switch(param) {
                case 'fov': sliderId = 'fov-slider'; updateFov(val); break;
                case 'zoom': sliderId = 'zoom-slider'; updateZoom(val); break;
                case 'opacity': sliderId = 'opacity-slider'; material.opacity = val; break;
                case 'roughness': sliderId = 'roughness-slider'; material.roughness = val; break;
                case 'pointSize': sliderId = 'size-slider'; currentPointSize = val; updatePointAppearance(); break;
                case 'edgeAngle': sliderId = 'edge-angle-slider'; currentEdgeThreshold = val; updateGeometry(); break;
            }

            if(sliderId) {
                const slider = document.getElementById(sliderId);
                const display = document.getElementById(sliderId.replace('slider', 'val'));
                if (slider) { slider.value = val; slider.dispatchEvent(new Event('input')); }
                if (display) { display.textContent = val + (sliderId.includes('angle') || sliderId.includes('fov') ? '째' : ''); }
            }
        };

        // --- UI Helpers ---
        const bindSlider = (id, valId, callback) => {
            const slider = document.getElementById(id);
            const valDisplay = document.getElementById(valId);
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (valDisplay) valDisplay.textContent = val + (id.includes('angle') || id.includes('fov') ? '째' : '');
                callback(val);
            });
        };

        // --- Logic Functions ---
        function updateFogDensity(distance) {
            const baseDist = 6.0;
            const newDensity = Math.max(0.00001, initialFogDensity * (baseDist / distance));
            scene.fog.density = newDensity;
        }

        function updateFov(val) {
            const oldFov = camera.fov;
            const newFov = val;
            const dist = camera.position.distanceTo(controls.target);
            const oldRad = (oldFov * Math.PI) / 360; 
            const newRad = (newFov * Math.PI) / 360;
            const newDist = dist * Math.tan(oldRad) / Math.tan(newRad);

            camera.fov = newFov;
            camera.updateProjectionMatrix();

            const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(dir.multiplyScalar(newDist));
            
            updateFogDensity(newDist);

            const zoomSlider = document.getElementById('zoom-slider');
            if(zoomSlider) zoomSlider.value = getZoomSliderValue(newDist);
            
            controls.update();
        }

        bindSlider('fov-slider', 'fov-val', updateFov);
        bindSlider('opacity-slider', 'opacity-val', (val) => material.opacity = val);
        bindSlider('roughness-slider', 'roughness-val', (val) => material.roughness = val);
        bindSlider('size-slider', 'size-val', (val) => { currentPointSize = val; updatePointAppearance(); });
        bindSlider('edge-angle-slider', 'edge-angle-val', (val) => { currentEdgeThreshold = val; updateGeometry(); });

        function updateZoom(sliderVal) {
            const distance = getZoomDistance(sliderVal);
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(distance));
            controls.update();
            updateFogDensity(distance);
        }

        document.getElementById('zoom-slider').addEventListener('input', (e) => updateZoom(parseFloat(e.target.value)));
        
        controls.addEventListener('change', () => {
            const dist = camera.position.distanceTo(controls.target);
            const slider = document.getElementById('zoom-slider');
            if (document.activeElement !== slider) {
                slider.value = getZoomSliderValue(dist);
                updateFogDensity(dist);
            }
        });

        function updatePointAppearance() {
             pointMeshes.forEach(mesh => {
                if(currentPointSize <= 0.001) {
                    mesh.visible = false;
                } else {
                    mesh.visible = true;
                    mesh.scale.set(currentPointSize, currentPointSize, currentPointSize);
                }
            });
            updateGeometry();
        }

        function reconcileParticles(newTargetPoints) {
            const newCount = newTargetPoints.length;
            const currentCount = particles.length;

            targets = [];
            for(let i=0; i<newCount; i++) targets.push(newTargetPoints[i].clone());

            if (newCount > currentCount) {
                for (let i = currentCount; i < newCount; i++) {
                    const p = new THREE.Vector3();
                    if (currentCount > 0) {
                        const parentIndex = i % currentCount; 
                        p.copy(particles[parentIndex]); 
                    } else {
                        p.copy(targets[i]);
                    }
                    particles.push(p);

                    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
                    mesh.scale.set(currentPointSize, currentPointSize, currentPointSize);
                    mesh.position.copy(p);
                    shapeGroup.add(mesh);
                    pointMeshes.push(mesh);
                }
            } else if (newCount < currentCount) {
                for (let i = currentCount - 1; i >= newCount; i--) {
                    shapeGroup.remove(pointMeshes[i]);
                }
                particles.splice(newCount);
                pointMeshes.splice(newCount);
            }
        }

        function init(shapeName) {
            const points = Geometries[shapeName]();
            reconcileParticles(points);
            particles.forEach((p, i) => p.copy(targets[i]));
            updateGeometry();
            history = []; 
            updateUndoBtn();
        }

        function updateGeometry() {
            if (particles.length < 4) return;
            const hull = new ConvexHull();
            hull.setFromPoints(particles);

            const geometry = new ConvexGeometry(particles);
            if(mainMesh.geometry) mainMesh.geometry.dispose();
            mainMesh.geometry = geometry;

            if(wireframeMesh.geometry) wireframeMesh.geometry.dispose();
            const edges = new THREE.EdgesGeometry(geometry, currentEdgeThreshold);
            wireframeMesh.geometry = edges;

            const activeVertices = new Set();
            hull.faces.forEach(face => {
                let edge = face.edge;
                do {
                    activeVertices.add(edge.head().point);
                    edge = edge.next;
                } while (edge !== face.edge);
            });

            particles.forEach((p, i) => {
                pointMeshes[i].position.copy(p);
                pointMeshes[i].scale.set(currentPointSize, currentPointSize, currentPointSize);
                if (currentPointSize > 0.001) {
                    pointMeshes[i].visible = activeVertices.has(p);
                } else {
                    pointMeshes[i].visible = false;
                }
            });
        }

        function getUniqueEdges(points) {
            const hull = new ConvexHull();
            hull.setFromPoints(points);
            const edgeSet = new Set();
            const uniqueEdges = [];
            const PRECISION = 4;

            hull.faces.forEach(face => {
                let edge = face.edge;
                do {
                    const v1 = edge.head().point;
                    const v2 = edge.tail().point;
                    const id1 = `${v1.x.toFixed(PRECISION)},${v1.y.toFixed(PRECISION)},${v1.z.toFixed(PRECISION)}`;
                    const id2 = `${v2.x.toFixed(PRECISION)},${v2.y.toFixed(PRECISION)},${v2.z.toFixed(PRECISION)}`;
                    const key = id1 < id2 ? `${id1}_${id2}` : `${id2}_${id1}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        uniqueEdges.push({ start: v1, end: v2 });
                    }
                    edge = edge.next;
                } while (edge !== face.edge);
            });
            return uniqueEdges;
        }

        // --- Global Functions for HTML ---
        window.truncateShape = (type) => {
            const currentPoints = targets.map(p => p.clone());
            history.push(currentPoints);
            updateUndoBtn();

            const edges = getUniqueEdges(currentPoints);
            const newPoints = [];
            const exists = (pt) => {
                for (let existing of newPoints) {
                    if (existing.distanceToSquared(pt) < 0.0001) return true;
                }
                return false;
            };

            edges.forEach(edge => {
                const vStart = edge.start;
                const vEnd = edge.end;
                const vec = new THREE.Vector3().subVectors(vEnd, vStart);
                if (type === 'midpoint') {
                    const mid = new THREE.Vector3().copy(vStart).addScaledVector(vec, 0.5);
                    if (!exists(mid)) newPoints.push(mid);
                } else if (type === 'trisection') {
                    const t1 = new THREE.Vector3().copy(vStart).addScaledVector(vec, 1/3);
                    const t2 = new THREE.Vector3().copy(vStart).addScaledVector(vec, 2/3);
                    if (!exists(t1)) newPoints.push(t1);
                    if (!exists(t2)) newPoints.push(t2);
                }
            });
            reconcileParticles(newPoints);
        };

        window.undo = () => {
            if (history.length === 0) return;
            const prevPoints = history.pop();
            reconcileParticles(prevPoints);
            updateUndoBtn();
        };

        function updateUndoBtn() {
            const btn = document.getElementById('undo-btn');
            btn.disabled = history.length === 0;
            btn.style.opacity = history.length === 0 ? '0.3' : '1';
        }

        window.morphTo = (shape, btnElement) => {
            history = [];
            updateUndoBtn();
            if(btnElement) {
                document.querySelectorAll('.row .btn').forEach(b => {
                    // check if it's a shape button (simple heuristic)
                    if(b.textContent.match(/TETRA|CUBE|OCTA|DODECA|ICOSA/)) b.classList.remove('active');
                });
                btnElement.classList.add('active');
            }
            const newPoints = Geometries[shape]();
            reconcileParticles(newPoints);
        };

        const LERP_SPEED = 0.1;

        function animate() {
            requestAnimationFrame(animate);
            let needsUpdate = false;
            for (let i = 0; i < particles.length; i++) {
                if (!targets[i]) continue;
                const dist = particles[i].distanceTo(targets[i]);
                if (dist > 0.001) {
                    particles[i].lerp(targets[i], LERP_SPEED);
                    needsUpdate = true;
                } else {
                    particles[i].copy(targets[i]);
                }
            }
            if (needsUpdate || particles.length > 0) updateGeometry();

            shapeGroup.rotation.y += 0.003;
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Init ---
        init('dodecahedron');

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
