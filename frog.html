<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404 Not Found</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #202124; /* Chrome Dark Mode Background */
            color: #bdc1c6; /* Chrome Text Color */
            font-family: 'Segoe UI', Tahoma, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
            cursor: default;
        }

        /* 本物のレイアウト比率に合わせる */
        #content-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 600px;
            width: 100%;
            padding: 0 20px;
        }

        #canvas-container {
            position: relative;
            width: 150px; /* アイコンのリアルなサイズ感 */
            height: 150px;
            margin-bottom: 30px;
            z-index: 10;
        }

        canvas {
            width: 100%;
            height: 100%;
            /* ぼかし除去。ピクセルパーフェクトを目指す */
            filter: none; 
            display: block;
        }

        .error-text {
            text-align: center;
            opacity: 1;
            z-index: 5;
            position: relative;
            transition: opacity 1s;
        }

        h1 {
            font-size: 24px;
            font-weight: 500;
            margin: 0 0 16px 0;
            color: #bdc1c6;
            line-height: 1.3;
        }

        p {
            font-size: 15px;
            line-height: 1.6;
            margin: 0;
            color: #9aa0a6;
        }

        .gray-text {
            color: #5f6368;
            font-size: 13px;
            margin-top: 10px;
            display: block;
        }

        #abyss-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 100;
        }

        .nightmare-mode body {
            background-color: #050000;
        }
        
        /* ノイズレイヤー */
        .static-noise {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)" opacity="0.1"/%3E%3C/svg%3E');
            opacity: 0;
            pointer-events: none;
            z-index: 90;
            mix-blend-mode: overlay;
        }

    </style>
</head>
<body>

    <div class="static-noise" id="static-noise"></div>

    <div id="content-wrapper">
        <div id="canvas-container">
            <!-- 高解像度対応のためにサイズを2倍に設定 -->
            <canvas id="morphCanvas" width="300" height="300"></canvas>
        </div>

        <div class="error-text" id="text-container">
            <h1 id="error-title">404. That’s an error.</h1>
            <p id="error-desc">The requested URL was not found on this server. <br> <span class="gray-text">That’s all we know.</span></p>
        </div>
    </div>

    <div id="abyss-overlay"></div>

    <script>
        const canvas = document.getElementById('morphCanvas');
        const ctx = canvas.getContext('2d');
        const textContainer = document.getElementById('text-container');
        const titleEl = document.getElementById('error-title');
        const noiseEl = document.getElementById('static-noise');
        const abyssOverlay = document.getElementById('abyss-overlay');

        const STATE = {
            IDLE: 0,      // 本物のエラー画面
            GLITCH: 1,    // 違和感
            MUTATION: 2,  // 崩壊・肉体化
            LUNGE: 3,     // 捕食
            DONE: 4
        };

        let currentState = STATE.IDLE;
        let startTime = Date.now();
        
        const TIMING = {
            IDLE: 4000,
            GLITCH: 2000,
            MUTATION: 3000,
            LUNGE: 200
        };

        let morphFactor = 0;

        // 肉体テクスチャ
        const particles = [];
        for(let i=0; i<60; i++) {
            particles.push({
                angle: Math.random() * Math.PI * 2,
                dist: Math.random(),
                size: Math.random() * 5 + 2,
                type: Math.random() > 0.7 ? 'pustule' : 'vein'
            });
        }

        // ノイズ関数
        function noise(x, y, t) {
            return Math.sin(x * 8 + t) * Math.cos(y * 7 + t * 1.2) * Math.sin(t * 0.8);
        }

        function draw() {
            const now = Date.now();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // 揺れ計算
            let shakeX = 0;
            let shakeY = 0;
            
            if (currentState === STATE.GLITCH) {
                if (Math.random() < 0.15) {
                    shakeX = (Math.random() - 0.5) * 4;
                }
            } else if (currentState >= STATE.MUTATION) {
                shakeX = Math.sin(now / 40) * 3;
                shakeY = Math.cos(now / 35) * 3;
                if (Math.random() < 0.08) { 
                    shakeX += (Math.random()-0.5) * 15;
                    shakeY += (Math.random()-0.5) * 15;
                }
            }

            ctx.save();
            ctx.translate(cx + shakeX, cy + shakeY);

            // --- 描画ロジック ---
            
            // 色: Chrome Gray (#bdc1c6) -> Mutated Green/Red
            // リアルなアイコンカラー
            const startColor = {r:189, g:193, b:198}; // #bdc1c6
            const endColor = {r:40, g:50, b:30};     // Dark Swamp

            let r = startColor.r + (endColor.r - startColor.r) * morphFactor;
            let g = startColor.g + (endColor.g - startColor.g) * morphFactor;
            let b = startColor.b + (endColor.b - startColor.b) * morphFactor;

            if (morphFactor > 0.6) {
                // 脈動
                const beat = Math.sin(now/100) * 20;
                r += beat;
            }

            ctx.fillStyle = `rgb(${r},${g},${b})`;

            // --- SHAPE GENERATION ---
            ctx.beginPath();

            const baseW = 140; // Icon width
            const baseH = 180; // Icon height
            const foldSize = 40; // Dog ear size

            if (morphFactor < 0.05) {
                // REALISTIC FILE ICON MODE
                // ベジェ曲線を使わず、直線で正確に描画して「無機質感」を出す
                const x = -baseW / 2;
                const y = -baseH / 2;
                
                // Main body
                ctx.moveTo(x, y); // Top Left
                ctx.lineTo(x + baseW - foldSize, y); // Top Edge
                ctx.lineTo(x + baseW, y + foldSize); // Fold slope (hidden by fold triangle usually, but here main shape)
                ctx.lineTo(x + baseW, y + baseH); // Right Edge
                ctx.lineTo(x, y + baseH); // Bottom Edge
                ctx.closePath();
                ctx.fill();

                // The Folded Corner (Dog Ear) - 別色で描画して立体感を出す
                // 実際のアイコンは少し暗い色
                ctx.fillStyle = `rgb(${r-30},${g-30},${b-30})`; 
                ctx.beginPath();
                ctx.moveTo(x + baseW - foldSize, y);
                ctx.lineTo(x + baseW - foldSize, y + foldSize);
                ctx.lineTo(x + baseW, y + foldSize);
                ctx.fill();

            } else {
                // MUTATION MODE (Blob)
                // ファイルの矩形から、カエルの不定形へモーフィング
                
                const points = 40;
                for (let i = 0; i <= points; i++) {
                    const ang = (i / points) * Math.PI * 2 - (Math.PI/2); // Top start
                    
                    // Rectangular morph logic
                    // 簡易的に矩形に近い形を作る
                    let radX = baseW / 2;
                    let radY = baseH / 2;
                    
                    // カエル化：下半分が膨らむ
                    if (Math.sin(ang) > 0) {
                        radX += 60 * morphFactor * Math.sin(ang); 
                    }

                    // ノイズによる歪み
                    const n = noise(Math.cos(ang), Math.sin(ang), now/300 + morphFactor*5);
                    const distortion = n * 40 * morphFactor;
                    
                    // 右上の「折れ」部分のシミュレーション（溶けるように消える）
                    // 角度が右上のあたりのとき
                    let cornerOffset = 0;
                    if (ang > -0.5 && ang < 0) {
                        cornerOffset = -20 * (1 - morphFactor); // 初期は凹んでいる
                    }

                    const px = Math.cos(ang) * (radX + distortion) + cornerOffset;
                    const py = Math.sin(ang) * (radY + distortion) + cornerOffset;
                    
                    if (i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.fill();
            }

            // --- TEXTURE (Organic Only) ---
            if (morphFactor > 0.1) {
                ctx.globalCompositeOperation = 'multiply';
                for (let p of particles) {
                    const d = p.dist * (baseW/1.5 * (1+morphFactor));
                    const px = Math.cos(p.angle) * d;
                    const py = Math.sin(p.angle) * d + (40 * morphFactor);
                    const size = p.size * morphFactor * (1 + Math.sin(now/200)*0.2);

                    ctx.fillStyle = p.type === 'pustule' 
                        ? `rgba(180, 160, 50, ${0.4 * morphFactor})` 
                        : `rgba(80, 20, 20, ${0.3 * morphFactor})`;
                    
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.globalCompositeOperation = 'source-over';
            }

            // --- FACE ---
            
            // Icon Face Position
            // ファイルアイコンの顔は少し上寄り
            const faceY = -10 - (20 * morphFactor); 
            const eyeDist = 35 + (30 * morphFactor);
            
            // 左目
            drawEye(ctx, -eyeDist, faceY, morphFactor, now, -1);
            // 右目
            drawEye(ctx, eyeDist, faceY, morphFactor, now, 1);

            // --- MOUTH ---
            const mouthY = 35 + (20 * morphFactor);
            const mouthW = 40 + (180 * morphFactor);
            
            ctx.beginPath();
            
            if (currentState < STATE.LUNGE) {
                // Line Mouth
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                
                // 色：アイコン時は暗いグレー、変異時は黒/血
                ctx.strokeStyle = (morphFactor < 0.1) ? '#202124' : '#100000';

                // Path
                const curve = 10 * (1 - morphFactor); // への字（Sad）
                
                if (morphFactor < 0.1) {
                    // Perfect Arc for Icon
                    ctx.moveTo(-mouthW/2, mouthY + curve);
                    ctx.quadraticCurveTo(0, mouthY - curve, mouthW/2, mouthY + curve);
                    ctx.stroke();
                } else {
                    // Jagged, ripping mouth
                    ctx.moveTo(-mouthW/2, mouthY);
                    
                    const jaggedness = 10 * morphFactor;
                    const drool = Math.sin(now/200) * 15 * morphFactor;

                    ctx.bezierCurveTo(
                        -mouthW/3, mouthY - 20*morphFactor + drool, 
                        mouthW/3, mouthY + 20*morphFactor + drool, 
                        mouthW/2, mouthY
                    );
                    ctx.stroke();
                    
                    // Drool
                    if (morphFactor > 0.8) {
                        ctx.fillStyle = 'rgba(150, 255, 150, 0.4)';
                        ctx.beginPath();
                        ctx.arc(0, mouthY + 20 + (now%800)/20, 4, 0, Math.PI*2);
                        ctx.fill();
                    }
                }

            } else {
                // LUNGE MOUTH (ABYSS)
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(-300, mouthY);
                ctx.quadraticCurveTo(0, mouthY - 400, 300, mouthY);
                ctx.quadraticCurveTo(0, mouthY + 600, -300, mouthY);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawEye(ctx, x, y, morph, time, side) {
            ctx.save();
            ctx.translate(x, y);

            // 変異時のまぶた
            if (morph > 0.2) {
                const s = 25 * morph;
                ctx.fillStyle = `rgb(${80-s}, ${90-s}, ${70-s})`;
                ctx.beginPath();
                ctx.arc(0, 0, 20 + s, 0, Math.PI*2);
                ctx.fill();
            }

            // 白目描画（アイコン時は背景色と同じ＝透明に見せる）
            if (morph > 0.05) {
                ctx.fillStyle = `rgb(240, ${240-morph*100}, ${240-morph*150})`; // 白 -> 黄ばみ
                ctx.beginPath();
                ctx.arc(0, 0, 18 + (10*morph), 0, Math.PI*2);
                ctx.fill();
            }

            // 瞳孔 / アイコンのバツ印
            if (morph < 0.15) {
                // ICON MODE: Pixel perfect "x" (or square eyes often used in sad icons)
                // Let's use the 'x' for sad file
                ctx.strokeStyle = '#202124'; // Icon body color background -> dark eye
                ctx.lineWidth = 5;
                ctx.lineCap = 'round';
                
                const size = 8;
                ctx.beginPath();
                ctx.moveTo(-size, -size); ctx.lineTo(size, size);
                ctx.moveTo(size, -size); ctx.lineTo(-size, size);
                ctx.stroke();

            } else {
                // FROG MODE
                const size = 18 + (10*morph);
                
                // 眼球運動
                let lx = 0, ly = 0;
                if (morph > 0.5) {
                    lx = Math.sin(time/250 + side) * size * 0.4;
                    ly = Math.cos(time/300) * size * 0.4;
                }
                
                ctx.translate(lx, ly);

                // 瞳孔
                ctx.fillStyle = '#000';
                ctx.beginPath();
                // 縦長スリット
                ctx.ellipse(0, 0, size*0.3, size*0.8, 0, 0, Math.PI*2);
                ctx.fill();

                // ハイライト
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.beginPath();
                ctx.arc(-size*0.3, -size*0.3, size*0.15, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.restore();
        }

        function loop() {
            const now = Date.now();
            const elapsed = now - startTime;

            if (currentState === STATE.IDLE) {
                if (elapsed > TIMING.IDLE) {
                    currentState = STATE.GLITCH;
                    startTime = now;
                }
            } else if (currentState === STATE.GLITCH) {
                const progress = elapsed / TIMING.GLITCH;
                
                // サブリミナル：一瞬だけテキストが変わる
                if (Math.random() < 0.05) {
                    titleEl.innerText = "404. It's h_re.";
                    // 少しだけ色ずれ
                    textContainer.style.transform = `translate(${Math.random()*2}px, ${Math.random()*2}px)`;
                } else {
                    titleEl.innerText = "404. That’s an error.";
                    textContainer.style.transform = "none";
                }

                if (progress >= 1) {
                    currentState = STATE.MUTATION;
                    startTime = now;
                    noiseEl.style.opacity = 0.2; // ノイズ開始
                    document.body.style.transition = "background-color 3s";
                    document.body.style.backgroundColor = "#1a0d0d"; // 血のような暗闇へ
                    titleEl.style.color = "#800";
                    titleEl.innerText = "FOUND YOU";
                    // 説明文を消して不気味に
                    document.getElementById('error-desc').style.opacity = 0;
                }

            } else if (currentState === STATE.MUTATION) {
                const progress = Math.min(elapsed / TIMING.MUTATION, 1);
                morphFactor = progress * progress * (3 - 2 * progress); // EaseInOut

                if (progress >= 1) {
                    currentState = STATE.LUNGE;
                    startTime = now;
                }

            } else if (currentState === STATE.LUNGE) {
                const progress = Math.min(elapsed / TIMING.LUNGE, 1);
                
                // 画面外からの飛びかかり（ズーム）
                const scale = 1 + (Math.pow(progress, 4) * 80);
                canvas.style.transform = `scale(${scale})`;
                
                abyssOverlay.style.opacity = progress * 1.5;

                if (progress >= 1) {
                    currentState = STATE.DONE;
                    setTimeout(() => {
                         try { window.location.href = './abyss.html'; } catch(e){}
                    }, 50);
                }
            }

            draw();
            requestAnimationFrame(loop);
        }

        draw();
        loop();

    </script>
</body>
</html>